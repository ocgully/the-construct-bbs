---
phase: 07-news-bulletins
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/Cargo.toml
  - backend/src/config.rs
  - backend/src/services/news.rs
  - backend/src/services/mod.rs
  - config.toml
autonomous: true

must_haves:
  truths:
    - "feed-rs crate is available for RSS parsing"
    - "NewsConfig loads feed URLs from config.toml"
    - "fetch_feeds function returns articles from configured RSS feeds"
    - "Feed errors are handled gracefully without crashing"
  artifacts:
    - path: "backend/src/services/news.rs"
      provides: "News fetching and article types"
      exports: ["NewsArticle", "FetchResult", "fetch_feeds"]
    - path: "backend/src/config.rs"
      provides: "NewsConfig struct"
      contains: "pub struct NewsConfig"
  key_links:
    - from: "backend/src/services/news.rs"
      to: "feed_rs::parser"
      via: "feed parsing"
      pattern: "feed_rs::parser::parse"
    - from: "backend/src/config.rs"
      to: "config.toml"
      via: "serde deserialization"
      pattern: "NewsConfig"
---

<objective>
Add feed-rs dependency and create news module foundation with fetching logic

Purpose: Establish the RSS feed parsing infrastructure required for the news system
Output: Working fetch_feeds function that retrieves articles from configured RSS feeds
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-news-bulletins/07-CONTEXT.md
@.planning/phases/07-news-bulletins/07-RESEARCH.md
@backend/src/config.rs
@backend/src/services/mod.rs
@backend/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add feed-rs dependency and NewsConfig</name>
  <files>backend/Cargo.toml, backend/src/config.rs, config.toml</files>
  <action>
1. Add feed-rs to backend/Cargo.toml:
   ```toml
   feed-rs = "2.3"
   ```
   Note: reqwest is NOT needed - feed-rs handles parsing, we'll use reqwest from tokio for HTTP

2. Actually, check if reqwest is needed. Looking at research - yes, reqwest is needed for HTTP fetching.
   Add reqwest with rustls-tls feature:
   ```toml
   reqwest = { version = "0.12", default-features = false, features = ["rustls-tls"] }
   ```

3. Add NewsConfig to backend/src/config.rs:
   ```rust
   #[derive(Debug, Deserialize, Serialize, Clone)]
   pub struct NewsConfig {
       #[serde(default = "default_feeds")]
       pub feeds: Vec<NewsFeed>,
   }

   #[derive(Debug, Deserialize, Serialize, Clone)]
   pub struct NewsFeed {
       pub name: String,
       pub url: String,
   }

   fn default_feeds() -> Vec<NewsFeed> {
       vec![
           NewsFeed {
               name: "Hacker News".to_string(),
               url: "https://hnrss.org/newest".to_string(),
           },
       ]
   }

   impl Default for NewsConfig {
       fn default() -> Self {
           Self {
               feeds: default_feeds(),
           }
       }
   }
   ```

4. Add news field to Config struct:
   ```rust
   #[serde(default)]
   pub news: NewsConfig,
   ```

5. Add news section to config.toml with default feeds:
   ```toml
   [news]
   [[news.feeds]]
   name = "Hacker News"
   url = "https://hnrss.org/newest"

   [[news.feeds]]
   name = "Ars Technica"
   url = "https://feeds.arstechnica.com/arstechnica/index"
   ```
  </action>
  <verify>Run `cd C:/Git/bbs/backend && cargo check` - should compile without errors</verify>
  <done>feed-rs and reqwest dependencies added, NewsConfig struct defined, config.toml has default feeds</done>
</task>

<task type="auto">
  <name>Task 2: Create news service module with fetch logic</name>
  <files>backend/src/services/news.rs, backend/src/services/mod.rs</files>
  <action>
1. Create backend/src/services/news.rs with:

   ```rust
   use std::time::Duration;

   /// A single news article extracted from an RSS feed
   #[derive(Debug, Clone)]
   pub struct NewsArticle {
       pub source: String,
       pub title: String,
       pub link: String,
       pub snippet: String,
       pub published: Option<String>,
   }

   /// Result of fetching all configured feeds
   #[derive(Debug)]
   pub struct FetchResult {
       pub articles: Vec<NewsArticle>,
       pub errors: Vec<String>,
   }

   /// Fetch and parse a single RSS feed
   async fn fetch_feed(name: &str, url: &str) -> Result<Vec<NewsArticle>, String> {
       // Build HTTP client with timeout
       let client = reqwest::Client::builder()
           .timeout(Duration::from_secs(10))
           .build()
           .map_err(|e| format!("HTTP client error: {}", e))?;

       // Fetch feed content
       let response = client.get(url).await
           .map_err(|e| format!("Failed to fetch: {}", friendly_error(&e)))?;

       let bytes = response.bytes().await
           .map_err(|e| format!("Failed to read response: {}", e))?;

       // Parse feed (handles RSS, Atom, JSON Feed automatically)
       let feed = feed_rs::parser::parse(&bytes[..])
           .map_err(|e| format!("Failed to parse feed: {}", e))?;

       // Extract articles (10 most recent per user decision)
       let articles: Vec<NewsArticle> = feed.entries.iter()
           .take(10)
           .map(|entry| {
               NewsArticle {
                   source: name.to_string(),
                   title: entry.title.as_ref()
                       .and_then(|t| t.content.as_ref())
                       .map(|s| strip_html(s))
                       .unwrap_or_else(|| "(No title)".to_string()),
                   link: entry.links.first()
                       .map(|link| link.href.clone())
                       .unwrap_or_default(),
                   snippet: entry.summary.as_ref()
                       .and_then(|s| s.content.as_ref())
                       .map(|s| strip_html(s))
                       .or_else(|| entry.content.as_ref()
                           .and_then(|c| c.body.as_ref())
                           .map(|s| strip_html(s)))
                       .unwrap_or_default(),
                   published: entry.published.or(entry.updated)
                       .map(|dt| dt.to_rfc3339()),
               }
           })
           .collect();

       Ok(articles)
   }

   /// Fetch all configured feeds, returning articles grouped by source
   pub async fn fetch_feeds(feeds: &[crate::config::NewsFeed]) -> FetchResult {
       let mut articles = Vec::new();
       let mut errors = Vec::new();

       for feed in feeds {
           match fetch_feed(&feed.name, &feed.url).await {
               Ok(feed_articles) => {
                   articles.extend(feed_articles);
               }
               Err(e) => {
                   eprintln!("Feed fetch failed for {}: {}", feed.name, e);
                   errors.push(format!("{}: {}", feed.name, e));
               }
           }
       }

       FetchResult { articles, errors }
   }

   /// Convert HTTP errors to user-friendly messages
   fn friendly_error(err: &reqwest::Error) -> String {
       let msg = err.to_string();
       if msg.contains("timeout") || msg.contains("timed out") {
           "Connection timeout".to_string()
       } else if msg.contains("dns") || msg.contains("resolve") {
           "Site not found".to_string()
       } else if err.status().map(|s| s.as_u16() == 404).unwrap_or(false) {
           "Feed not found".to_string()
       } else {
           "Unavailable".to_string()
       }
   }

   /// Strip HTML tags from text (simple regex-free approach)
   fn strip_html(text: &str) -> String {
       let mut result = String::new();
       let mut in_tag = false;

       for ch in text.chars() {
           match ch {
               '<' => in_tag = true,
               '>' => in_tag = false,
               _ if !in_tag => result.push(ch),
               _ => {}
           }
       }

       // Decode common HTML entities
       result
           .replace("&amp;", "&")
           .replace("&lt;", "<")
           .replace("&gt;", ">")
           .replace("&quot;", "\"")
           .replace("&#39;", "'")
           .replace("&apos;", "'")
           .replace("&nbsp;", " ")
           .trim()
           .to_string()
   }
   ```

2. Update backend/src/services/mod.rs to export news module:
   Add `pub mod news;` to the module declarations.
  </action>
  <verify>Run `cd C:/Git/bbs/backend && cargo check` - should compile without errors</verify>
  <done>news.rs module created with NewsArticle, FetchResult types and fetch_feeds function</done>
</task>

</tasks>

<verification>
1. `cd C:/Git/bbs/backend && cargo check` passes
2. NewsConfig is accessible from config module
3. News module exports NewsArticle, FetchResult, fetch_feeds
</verification>

<success_criteria>
- feed-rs and reqwest crates compile successfully
- NewsConfig struct deserializes from config.toml
- fetch_feeds function signature is correct and accessible
- HTML stripping function handles common entities
</success_criteria>

<output>
After completion, create `.planning/phases/07-news-bulletins/07-01-SUMMARY.md`
</output>
