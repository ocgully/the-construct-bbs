---
phase: 06-chat-real-time-communication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/connection/chat_manager.rs
  - backend/src/connection/mod.rs
  - backend/src/config.rs
  - backend/src/main.rs
autonomous: true

must_haves:
  truths:
    - "ChatManager can broadcast messages to multiple subscribers"
    - "ChatManager tracks who is currently in chat"
    - "Chat capacity is configurable and enforced"
  artifacts:
    - path: "backend/src/connection/chat_manager.rs"
      provides: "Broadcast channel management and participant tracking"
      exports: ["ChatManager", "ChatMessage"]
      min_lines: 80
    - path: "backend/src/config.rs"
      provides: "ChatConfig with capacity setting"
      contains: "ChatConfig"
  key_links:
    - from: "backend/src/main.rs"
      to: "ChatManager"
      via: "AppState field"
      pattern: "chat_manager: ChatManager"
---

<objective>
Create ChatManager with tokio::sync::broadcast channel for real-time message distribution.

Purpose: Foundation for multi-user chat - broadcast channel enables 1-to-many message delivery without manual iteration.
Output: ChatManager struct in AppState, ChatMessage enum, ChatConfig for capacity.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-chat-real-time-communication/06-CONTEXT.md
@.planning/phases/06-chat-real-time-communication/06-RESEARCH.md

Relevant existing code:
@backend/src/connection/node_manager.rs — pattern for RwLock participant tracking
@backend/src/main.rs — AppState struct, module wiring
@backend/src/config.rs — config struct patterns with serde defaults
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChatManager with broadcast channel</name>
  <files>backend/src/connection/chat_manager.rs, backend/src/connection/mod.rs</files>
  <action>
Create `backend/src/connection/chat_manager.rs`:

1. Define `ChatMessage` enum with Clone + Debug derives:
   - `Public { sender: String, text: String }` — regular chat message
   - `Action { sender: String, action: String }` — /me emotes
   - `System { text: String }` — system announcements (errors, capacity)
   - `Direct { from: String, to: String, text: String }` — private messages
   - `Join { handle: String }` — join announcement
   - `Leave { handle: String }` — leave announcement
   - `Page { from: String, to: String }` — page notification (triggers bell)

2. Create `ChatManager` struct:
   ```rust
   pub struct ChatManager {
       tx: broadcast::Sender<ChatMessage>,
       participants: Arc<RwLock<HashMap<i64, String>>>, // user_id -> handle
       capacity: usize,
   }
   ```

3. Implement methods:
   - `new(capacity: usize) -> Self` — create broadcast channel with capacity 100
   - `subscribe() -> broadcast::Receiver<ChatMessage>` — return tx.subscribe()
   - `broadcast(&self, msg: ChatMessage)` — send via tx, ignore no-receivers error
   - `join(&self, user_id: i64, handle: String) -> Result<(), String>` — check capacity, add to participants
   - `leave(&self, user_id: i64)` — remove from participants
   - `get_participants(&self) -> Vec<String>` — return list of handles
   - `is_in_chat(&self, user_id: i64) -> bool` — check if user is in participants
   - `get_participant_count(&self) -> usize` — return current count
   - `get_handle_user_id(&self, handle: &str) -> Option<i64>` — reverse lookup for /msg

Pattern from RESEARCH.md: Use `let _ = self.tx.send(msg);` to ignore RecvError when no subscribers.

4. Update `backend/src/connection/mod.rs`:
   - Add `pub mod chat_manager;`
   - Add `pub use chat_manager::{ChatManager, ChatMessage};`
  </action>
  <verify>cargo check --manifest-path backend/Cargo.toml</verify>
  <done>ChatManager compiles with broadcast channel, participant tracking, and all required methods</done>
</task>

<task type="auto">
  <name>Task 2: Add ChatConfig and wire ChatManager into AppState</name>
  <files>backend/src/config.rs, backend/src/main.rs</files>
  <action>
1. In `backend/src/config.rs`:
   - Add `ChatConfig` struct:
     ```rust
     #[derive(Debug, Deserialize, Serialize, Clone)]
     pub struct ChatConfig {
         #[serde(default = "default_chat_capacity")]
         pub capacity: usize,
     }

     fn default_chat_capacity() -> usize {
         32 // Allows up to 32 users in chat (2x default max_nodes)
     }

     impl Default for ChatConfig {
         fn default() -> Self {
             Self {
                 capacity: default_chat_capacity(),
             }
         }
     }
     ```
   - Add to `Config` struct: `#[serde(default)] pub chat: ChatConfig,`

2. In `backend/src/main.rs`:
   - Add import: `use connection::ChatManager;`
   - Add to `AppState` struct: `pub(crate) chat_manager: ChatManager,`
   - Initialize after node_manager:
     ```rust
     let chat_manager = ChatManager::new(config.chat.capacity);
     println!("Chat capacity: {} users", config.chat.capacity);
     ```
   - Add to AppState initialization: `chat_manager,`
  </action>
  <verify>cargo build --manifest-path backend/Cargo.toml</verify>
  <done>ChatManager available in AppState, ChatConfig has serde defaults, server prints chat capacity on startup</done>
</task>

</tasks>

<verification>
1. `cargo build --manifest-path backend/Cargo.toml` succeeds
2. `cargo test --manifest-path backend/Cargo.toml` passes (no new tests yet, but existing tests still work)
3. Server starts and prints chat capacity: "Chat capacity: 32 users"
</verification>

<success_criteria>
- ChatManager struct exists with broadcast channel
- ChatMessage enum has all 7 variants
- ChatConfig with capacity setting loads from config.toml
- AppState includes chat_manager field
- Server compiles and starts successfully
</success_criteria>

<output>
After completion, create `.planning/phases/06-chat-real-time-communication/06-01-SUMMARY.md`
</output>
