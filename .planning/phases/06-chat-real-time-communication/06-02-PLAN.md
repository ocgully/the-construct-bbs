---
phase: 06-chat-real-time-communication
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/chat.rs
  - backend/src/services/mod.rs
autonomous: true

must_haves:
  truths:
    - "Chat commands are parsed correctly (/me, /who, /quit, /msg, /r, /page, /help)"
    - "Chat messages render with correct colors and formats"
    - "Direct messages only render for sender and recipient"
  artifacts:
    - path: "backend/src/services/chat.rs"
      provides: "Command parsing and message rendering"
      exports: ["parse_chat_command", "ChatCommand", "render_chat_message", "render_chat_help"]
      min_lines: 150
  key_links:
    - from: "backend/src/services/chat.rs"
      to: "ChatMessage"
      via: "render function parameter"
      pattern: "fn render_chat_message.*ChatMessage"
---

<objective>
Create chat command parser and ANSI rendering functions.

Purpose: Pure functions for command parsing and message formatting, decoupled from session state for testability.
Output: ChatCommand enum, parse_chat_command(), render functions for all message types with BBS-authentic colors.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-chat-real-time-communication/06-CONTEXT.md
@.planning/phases/06-chat-real-time-communication/06-RESEARCH.md

Relevant existing code:
@backend/src/services/mail.rs — render function patterns, ComposeFlow state machine
@backend/src/terminal/ansi.rs — AnsiWriter, Color enum
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chat command parser</name>
  <files>backend/src/services/chat.rs</files>
  <action>
Create `backend/src/services/chat.rs`:

1. Define `ChatCommand` enum:
   ```rust
   pub enum ChatCommand {
       Empty,                                          // Empty input
       Message(String),                                // Regular chat message
       Quit,                                           // /quit or /q
       Help,                                           // /help or /?
       Who,                                            // /who
       Action(String),                                 // /me <action>
       Page(String),                                   // /page <handle>
       DirectMessage { target: String, text: String }, // /msg <handle> <message>
       Reply(String),                                  // /r <message>
       Unknown(String),                                // Unknown command
       Error(String),                                  // Usage error (e.g., /me with no action)
   }
   ```

2. Implement `parse_chat_command(input: &str) -> ChatCommand`:
   - Return `Empty` if trimmed input is empty
   - If doesn't start with `/`, return `Message(trimmed.to_string())`
   - Split on first space: cmd and args
   - Match cmd (case-insensitive):
     - `/quit` | `/q` -> `Quit`
     - `/help` | `/?` -> `Help`
     - `/who` -> `Who`
     - `/me` -> if args empty, `Error("Usage: /me <action>")`, else `Action(args)`
     - `/page` -> if args empty, `Error("Usage: /page <handle>")`, else `Page(first_word_of_args)`
     - `/msg` -> split args into target and text; if either empty, `Error("Usage: /msg <handle> <message>")`; else `DirectMessage { target, text }`
     - `/r` -> if args empty, `Error("Usage: /r <message>")`, else `Reply(args)`
     - _ -> `Unknown(cmd.to_string())`

Use `splitn(2, ' ')` pattern from RESEARCH.md for command/args separation.
  </action>
  <verify>cargo check --manifest-path backend/Cargo.toml</verify>
  <done>ChatCommand enum and parse_chat_command function compile</done>
</task>

<task type="auto">
  <name>Task 2: Create chat message rendering functions</name>
  <files>backend/src/services/chat.rs, backend/src/services/mod.rs</files>
  <action>
1. Add to `backend/src/services/chat.rs`:

Import ChatMessage from connection module (will be available after plan 01):
```rust
use crate::connection::ChatMessage;
use crate::terminal::{AnsiWriter, Color};
use chrono::Utc;
```

2. Implement `render_chat_message(msg: &ChatMessage, my_handle: &str) -> String`:

From CONTEXT.md:
- Public: `[HH:MM] Handle: Message text` — timestamp prefix, dark green handle, light green message
- Action: `* Handle waves` — asterisk prefix, light green, no timestamp, no colon
- System: `*** message ***` — yellow
- Direct: Only render if my_handle == from || my_handle == to
  - Format: `[HH:MM] -> TargetHandle: text` (if I'm sender) or `[HH:MM] <- SenderHandle: text` (if I'm recipient)
  - Use LightCyan for the arrow+handle, white for text
- Join: `*** Handle has joined the chat ***` — yellow
- Leave: `*** Handle has left the chat ***` — yellow
- Page: `*** Page from Handle ***` — yellow (this just shows the notification text)

```rust
pub fn render_chat_message(msg: &ChatMessage, my_handle: &str) -> String {
    let mut w = AnsiWriter::new();

    match msg {
        ChatMessage::Public { sender, text } => {
            let timestamp = Utc::now().format("%H:%M");
            w.write_str(&format!("[{}] ", timestamp));
            w.set_fg(Color::Green);
            w.write_str(sender);
            w.reset_color();
            w.write_str(": ");
            w.set_fg(Color::LightGreen);
            w.write_str(text);
            w.reset_color();
            w.writeln("");
        }
        ChatMessage::Action { sender, action } => {
            w.set_fg(Color::LightGreen);
            w.write_str("* ");
            w.write_str(sender);
            w.write_str(" ");
            w.write_str(action);
            w.reset_color();
            w.writeln("");
        }
        ChatMessage::System { text } => {
            w.set_fg(Color::Yellow);
            w.write_str("*** ");
            w.write_str(text);
            w.write_str(" ***");
            w.reset_color();
            w.writeln("");
        }
        ChatMessage::Direct { from, to, text } => {
            // Only render if I'm sender or recipient
            if from != my_handle && to != my_handle {
                return String::new();
            }
            let timestamp = Utc::now().format("%H:%M");
            let (prefix, other) = if from == my_handle {
                ("-> ", to.as_str())
            } else {
                ("<- ", from.as_str())
            };
            w.write_str(&format!("[{}] ", timestamp));
            w.set_fg(Color::LightCyan);
            w.write_str(prefix);
            w.write_str(other);
            w.reset_color();
            w.write_str(": ");
            w.set_fg(Color::White);
            w.write_str(text);
            w.reset_color();
            w.writeln("");
        }
        ChatMessage::Join { handle } => {
            w.set_fg(Color::Yellow);
            w.write_str(&format!("*** {} has joined the chat ***", handle));
            w.reset_color();
            w.writeln("");
        }
        ChatMessage::Leave { handle } => {
            w.set_fg(Color::Yellow);
            w.write_str(&format!("*** {} has left the chat ***", handle));
            w.reset_color();
            w.writeln("");
        }
        ChatMessage::Page { from, to: _ } => {
            w.set_fg(Color::Yellow);
            w.write_str(&format!("*** Page from {} ***", from));
            w.reset_color();
            w.writeln("");
        }
    }

    w.flush()
}
```

3. Implement `render_chat_help() -> String`:
```rust
pub fn render_chat_help() -> String {
    let mut w = AnsiWriter::new();
    w.set_fg(Color::LightCyan);
    w.writeln("Chat Commands:");
    w.reset_color();
    w.writeln("  /help, /?     - Show this help");
    w.writeln("  /who          - List users in chat");
    w.writeln("  /me <action>  - Perform action (e.g., /me waves)");
    w.writeln("  /msg <user> <message> - Send private message");
    w.writeln("  /r <message>  - Reply to last private message");
    w.writeln("  /page <user>  - Page a user (bell notification)");
    w.writeln("  /quit, /q     - Exit chat");
    w.writeln("");
    w.flush()
}
```

4. Implement `render_chat_who(participants: &[String]) -> String`:
```rust
pub fn render_chat_who(participants: &[String]) -> String {
    let mut w = AnsiWriter::new();
    w.set_fg(Color::LightCyan);
    w.writeln(&format!("Users in chat ({}):", participants.len()));
    w.reset_color();
    for handle in participants {
        w.writeln(&format!("  {}", handle));
    }
    w.writeln("");
    w.flush()
}
```

5. Implement `render_chat_welcome() -> String`:
```rust
pub fn render_chat_welcome() -> String {
    let mut w = AnsiWriter::new();
    w.set_fg(Color::LightCyan);
    w.writeln("=== The Construct Chat ===");
    w.reset_color();
    w.writeln("Type /help for commands, /quit to exit.");
    w.writeln("");
    w.flush()
}
```

6. Implement `render_chat_error(msg: &str) -> String`:
```rust
pub fn render_chat_error(msg: &str) -> String {
    let mut w = AnsiWriter::new();
    w.set_fg(Color::LightRed);
    w.write_str(msg);
    w.reset_color();
    w.writeln("");
    w.flush()
}
```

7. Update `backend/src/services/mod.rs`:
   - Add `pub mod chat;`
  </action>
  <verify>cargo build --manifest-path backend/Cargo.toml</verify>
  <done>All render functions compile and produce ANSI-formatted strings</done>
</task>

</tasks>

<verification>
1. `cargo build --manifest-path backend/Cargo.toml` succeeds
2. `cargo test --manifest-path backend/Cargo.toml` passes
3. Module exports are visible: `crate::services::chat::{parse_chat_command, ChatCommand, render_chat_message}`
</verification>

<success_criteria>
- ChatCommand enum covers all slash commands from CONTEXT.md
- parse_chat_command handles all command variations
- render_chat_message produces correct ANSI output for each message type
- Direct messages return empty string when user is not sender or recipient
- All colors match CONTEXT.md spec (green handle, light green message, yellow system)
</success_criteria>

<output>
After completion, create `.planning/phases/06-chat-real-time-communication/06-02-SUMMARY.md`
</output>
