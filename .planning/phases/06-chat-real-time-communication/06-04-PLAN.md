---
phase: 06-chat-real-time-communication
plan: 04
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - frontend/src/audio.ts
  - frontend/src/websocket.ts
  - frontend/public/audio/bell.mp3
autonomous: true

must_haves:
  truths:
    - "Bell sound plays when user is paged"
    - "Bell sound plays when user receives DM"
    - "JSON bell message intercepted (not written to terminal)"
  artifacts:
    - path: "frontend/src/audio.ts"
      provides: "Bell sound loading and playback"
      exports: ["loadBellSound", "playBellSound"]
    - path: "frontend/src/websocket.ts"
      provides: "Bell JSON message handling"
      contains: "parsed.type === 'bell'"
  key_links:
    - from: "frontend/src/websocket.ts"
      to: "playBellSound"
      via: "function call on bell message"
      pattern: "playBellSound"
---

<objective>
Add bell sound for chat paging and DM notifications.

Purpose: Authentic BBS paging experience - bell sound alerts user to incoming pages and direct messages.
Output: bell.mp3 loaded at startup, playBellSound() called when backend sends { type: "bell" } JSON.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-chat-real-time-communication/06-CONTEXT.md
@.planning/phases/06-chat-real-time-communication/06-RESEARCH.md

Relevant existing code:
@frontend/src/audio.ts — modem sound loading/playback pattern
@frontend/src/websocket.ts — JSON message interception pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add bell sound loading and playback</name>
  <files>frontend/src/audio.ts</files>
  <action>
1. Add bell buffer variable after the existing buffer declarations:
```typescript
let bellBuffer: AudioBuffer | null = null;
```

2. Update `loadModemSounds()` to also load the bell sound. Rename to `loadSounds()` or add a separate function.

Actually, to minimize changes, just add the bell loading to the existing function:

In `loadModemSounds()`, after loading failBuffer, add:
```typescript
const bellResp = await fetch('/audio/bell.mp3');
if (bellResp.ok) {
  const buf = await bellResp.arrayBuffer();
  bellBuffer = await audioContext.decodeAudioData(buf);
} else {
  console.warn('bell.mp3 not found, skipping');
}
```

3. Add export function:
```typescript
export async function playBellSound(): Promise<void> {
  return playBuffer(bellBuffer);
}
```
  </action>
  <verify>Check that frontend/src/audio.ts has the new exports</verify>
  <done>Bell sound loading and playback function added to audio.ts</done>
</task>

<task type="auto">
  <name>Task 2: Handle bell JSON message in WebSocket</name>
  <files>frontend/src/websocket.ts</files>
  <action>
1. Add import for playBellSound:
```typescript
import { playModemSuccess, playModemFail, playBellSound } from './audio';
```

2. In the `onmessage` handler, after the `parsed.type === 'timeout'` check, add:
```typescript
if (parsed.type === 'bell') {
  // Play bell sound for page/DM notification
  playBellSound();
  return; // Don't write JSON to terminal
}
```
  </action>
  <verify>npm run build in frontend directory succeeds</verify>
  <done>WebSocket handler intercepts bell messages and plays sound</done>
</task>

<task type="auto">
  <name>Task 3: Add bell.mp3 audio file</name>
  <files>frontend/public/audio/bell.mp3</files>
  <action>
The bell sound needs to be a short (0.3-0.5 second) terminal bell or chime sound.

Options:
1. Download a free terminal bell sound from a sound library
2. Generate a simple sine wave beep programmatically
3. Use Web Audio API to generate the tone at runtime (no file needed)

For simplicity and authenticity, use Web Audio API to generate a classic terminal bell tone.

UPDATE audio.ts to generate the bell programmatically instead of loading a file:

Replace the bell loading code with runtime generation:

```typescript
// Generate a simple terminal bell tone (~800Hz, 100ms)
// No external file needed
async function generateBellBuffer(): Promise<AudioBuffer | null> {
  if (!audioContext) return null;

  const sampleRate = audioContext.sampleRate;
  const duration = 0.15; // 150ms
  const frequency = 800; // Hz
  const numSamples = Math.floor(sampleRate * duration);

  const buffer = audioContext.createBuffer(1, numSamples, sampleRate);
  const data = buffer.getChannelData(0);

  for (let i = 0; i < numSamples; i++) {
    // Sine wave with exponential decay envelope
    const t = i / sampleRate;
    const envelope = Math.exp(-t * 20); // Decay factor
    data[i] = Math.sin(2 * Math.PI * frequency * t) * envelope * 0.3;
  }

  return buffer;
}
```

In `loadModemSounds()`, after loading the modem sounds:
```typescript
bellBuffer = await generateBellBuffer();
```

This approach:
- No external file dependency
- Classic terminal bell sound (800Hz sine with decay)
- Works immediately without downloading
- Authentic to the era
  </action>
  <verify>npm run build in frontend directory succeeds</verify>
  <done>Bell sound generated programmatically, no external file needed</done>
</task>

</tasks>

<verification>
1. `cd frontend && npm run build` succeeds
2. Manual test: Start server, connect, enter chat, have another user /page you, hear bell
3. Manual test: Receive DM (/msg), hear bell
4. Verify bell JSON message doesn't appear in terminal
</verification>

<success_criteria>
- Bell sound plays when backend sends { type: "bell" }
- Sound is short, audible, and appropriate volume
- JSON message is intercepted and not displayed
- No external audio file required (generated programmatically)
</success_criteria>

<output>
After completion, create `.planning/phases/06-chat-real-time-communication/06-04-SUMMARY.md`
</output>
