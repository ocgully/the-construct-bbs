---
phase: 06-chat-real-time-communication
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - backend/src/websocket/session.rs
autonomous: true

must_haves:
  truths:
    - "User can enter chat and see welcome message"
    - "User sees messages from all other users in real-time"
    - "User sees join/leave announcements"
    - "User can use /me, /who, /msg, /r, /page, /help, /quit commands"
    - "User exiting chat broadcasts leave announcement"
  artifacts:
    - path: "backend/src/websocket/session.rs"
      provides: "Chat state handling and broadcast receiver task"
      contains: "__chat__"
  key_links:
    - from: "backend/src/websocket/session.rs"
      to: "ChatManager"
      via: "subscribe and broadcast calls"
      pattern: "chat_manager.subscribe|chat_manager.broadcast"
    - from: "backend/src/websocket/session.rs"
      to: "render_chat_message"
      via: "message formatting"
      pattern: "render_chat_message"
---

<objective>
Integrate chat into session with broadcast receiver task and command handling.

Purpose: Wire ChatManager into session lifecycle so users can enter chat, see real-time messages, and use all commands.
Output: Working chat mode with __chat__ sentinel service, broadcast forwarding, and full command support.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-chat-real-time-communication/06-CONTEXT.md
@.planning/phases/06-chat-real-time-communication/06-RESEARCH.md
@.planning/phases/06-chat-real-time-communication/06-01-SUMMARY.md
@.planning/phases/06-chat-real-time-communication/06-02-SUMMARY.md

Relevant existing code:
@backend/src/websocket/session.rs â€” Session struct, AuthState, sentinel pattern (__mail_inbox__, etc.)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add chat imports and Session fields</name>
  <files>backend/src/websocket/session.rs</files>
  <action>
1. Add imports at top of session.rs:
```rust
use crate::connection::ChatMessage;
use crate::services::chat::{
    parse_chat_command, ChatCommand, render_chat_message, render_chat_help,
    render_chat_who, render_chat_welcome, render_chat_error,
};
use tokio::sync::broadcast;
use tokio_util::sync::CancellationToken;
```

2. Add fields to Session struct:
```rust
/// Handle of last DM sender for /r reply command
last_dm_sender: Option<String>,
/// Cancellation token for chat broadcast receiver task
chat_cancel: Option<CancellationToken>,
```

3. Initialize in `Session::new()`:
```rust
last_dm_sender: None,
chat_cancel: None,
```
  </action>
  <verify>cargo check --manifest-path backend/Cargo.toml</verify>
  <done>Session struct has new fields for chat state</done>
</task>

<task type="auto">
  <name>Task 2: Implement enter_chat and exit_chat methods</name>
  <files>backend/src/websocket/session.rs</files>
  <action>
Add methods to Session impl block:

```rust
/// Enter chat mode: join ChatManager, subscribe to broadcasts, spawn receiver task
async fn enter_chat(&mut self) {
    // Get user info
    let (user_id, handle) = match &self.auth_state {
        AuthState::Authenticated { user_id, handle, .. } => (*user_id, handle.clone()),
        _ => return,
    };

    // Try to join chat
    if let Err(e) = self.state.chat_manager.join(user_id, handle.clone()).await {
        let _ = self.tx.send(render_chat_error(&e)).await;
        return;
    }

    // Subscribe to broadcasts
    let mut rx = self.state.chat_manager.subscribe();

    // Broadcast join announcement
    self.state.chat_manager.broadcast(ChatMessage::Join { handle: handle.clone() }).await;

    // Send welcome message
    let _ = self.tx.send(render_chat_welcome()).await;

    // Set sentinel service
    self.current_service = Some("__chat__".to_string());

    // Update activity
    if let Some(node_id) = self.node_id {
        self.state.node_manager.update_activity(node_id, "In Chat").await;
    }

    // Spawn task to forward broadcasts to session tx
    let tx = self.tx.clone();
    let my_handle = handle.clone();
    let cancel = CancellationToken::new();
    let cancel_clone = cancel.clone();

    tokio::spawn(async move {
        loop {
            tokio::select! {
                _ = cancel_clone.cancelled() => {
                    break;
                }
                result = rx.recv() => {
                    match result {
                        Ok(msg) => {
                            let formatted = render_chat_message(&msg, &my_handle);
                            if !formatted.is_empty() {
                                // Check if this is a page for me (trigger bell)
                                if let ChatMessage::Page { to, .. } = &msg {
                                    if to == &my_handle {
                                        // Send bell JSON signal
                                        let _ = tx.send(r#"{"type":"bell"}"#.to_string()).await;
                                    }
                                }
                                // Check if this is a DM to me (trigger bell)
                                if let ChatMessage::Direct { from, to, .. } = &msg {
                                    if to == &my_handle && from != &my_handle {
                                        let _ = tx.send(r#"{"type":"bell"}"#.to_string()).await;
                                    }
                                }
                                let _ = tx.send(formatted).await;
                            }
                        }
                        Err(broadcast::error::RecvError::Lagged(n)) => {
                            let _ = tx.send(render_chat_error(&format!("Missed {} messages", n))).await;
                        }
                        Err(broadcast::error::RecvError::Closed) => {
                            break;
                        }
                    }
                }
            }
        }
    });

    self.chat_cancel = Some(cancel);
}

/// Exit chat mode: cancel receiver, broadcast leave, leave ChatManager
async fn exit_chat(&mut self) {
    // Cancel broadcast receiver task
    if let Some(cancel) = self.chat_cancel.take() {
        cancel.cancel();
    }

    // Get user info and broadcast leave
    if let AuthState::Authenticated { user_id, handle, .. } = &self.auth_state {
        // Broadcast leave announcement
        self.state.chat_manager.broadcast(ChatMessage::Leave { handle: handle.clone() }).await;

        // Leave ChatManager
        self.state.chat_manager.leave(*user_id).await;
    }

    // Clear sentinel
    self.current_service = None;

    // Update activity
    if let Some(node_id) = self.node_id {
        self.state.node_manager.update_activity(node_id, "Main Menu").await;
    }
}
```
  </action>
  <verify>cargo check --manifest-path backend/Cargo.toml</verify>
  <done>enter_chat and exit_chat methods compile</done>
</task>

<task type="auto">
  <name>Task 3: Implement chat input handler</name>
  <files>backend/src/websocket/session.rs</files>
  <action>
Add method to Session impl block:

```rust
/// Handle input while in chat mode
async fn handle_chat_input(&mut self, input: &str) {
    let (user_id, handle) = match &self.auth_state {
        AuthState::Authenticated { user_id, handle, .. } => (*user_id, handle.clone()),
        _ => return,
    };

    let cmd = parse_chat_command(input);

    match cmd {
        ChatCommand::Empty => {
            // Do nothing on empty input
        }
        ChatCommand::Message(text) => {
            self.state.chat_manager.broadcast(ChatMessage::Public {
                sender: handle,
                text,
            }).await;
        }
        ChatCommand::Quit => {
            self.exit_chat().await;
            // Return to main menu
            if let Some(ms) = &mut self.menu_session {
                ms.reset_to_main();
            }
            self.show_menu().await;
        }
        ChatCommand::Help => {
            let _ = self.tx.send(render_chat_help()).await;
        }
        ChatCommand::Who => {
            let participants = self.state.chat_manager.get_participants().await;
            let _ = self.tx.send(render_chat_who(&participants)).await;
        }
        ChatCommand::Action(action) => {
            self.state.chat_manager.broadcast(ChatMessage::Action {
                sender: handle,
                action,
            }).await;
        }
        ChatCommand::Page(target) => {
            // Check if target is in chat
            let participants = self.state.chat_manager.get_participants().await;
            let target_lower = target.to_lowercase();
            if let Some(found) = participants.iter().find(|h| h.to_lowercase() == target_lower) {
                self.state.chat_manager.broadcast(ChatMessage::Page {
                    from: handle,
                    to: found.clone(),
                }).await;
                let _ = self.tx.send(render_chat_error(&format!("Paged {}", found))).await;
            } else {
                let _ = self.tx.send(render_chat_error(&format!("{} is not in chat", target))).await;
            }
        }
        ChatCommand::DirectMessage { target, text } => {
            // Find target in chat (case-insensitive)
            let participants = self.state.chat_manager.get_participants().await;
            let target_lower = target.to_lowercase();
            if let Some(found) = participants.iter().find(|h| h.to_lowercase() == target_lower) {
                // Can't DM yourself
                if found.to_lowercase() == handle.to_lowercase() {
                    let _ = self.tx.send(render_chat_error("Cannot message yourself")).await;
                } else {
                    self.state.chat_manager.broadcast(ChatMessage::Direct {
                        from: handle,
                        to: found.clone(),
                        text,
                    }).await;
                }
            } else {
                let _ = self.tx.send(render_chat_error(&format!("{} is not in chat", target))).await;
            }
        }
        ChatCommand::Reply(text) => {
            if let Some(last_sender) = &self.last_dm_sender {
                // Check if they're still in chat
                let participants = self.state.chat_manager.get_participants().await;
                let target_lower = last_sender.to_lowercase();
                if participants.iter().any(|h| h.to_lowercase() == target_lower) {
                    self.state.chat_manager.broadcast(ChatMessage::Direct {
                        from: handle,
                        to: last_sender.clone(),
                        text,
                    }).await;
                } else {
                    let _ = self.tx.send(render_chat_error(&format!("{} is no longer in chat", last_sender))).await;
                }
            } else {
                let _ = self.tx.send(render_chat_error("No one to reply to")).await;
            }
        }
        ChatCommand::Unknown(cmd) => {
            let _ = self.tx.send(render_chat_error(&format!("Unknown command: {}. Type /help for available commands.", cmd))).await;
        }
        ChatCommand::Error(msg) => {
            let _ = self.tx.send(render_chat_error(&msg)).await;
        }
    }
}
```
  </action>
  <verify>cargo check --manifest-path backend/Cargo.toml</verify>
  <done>handle_chat_input processes all commands</done>
</task>

<task type="auto">
  <name>Task 4: Wire chat into handle_authenticated_input and on_disconnect</name>
  <files>backend/src/websocket/session.rs</files>
  <action>
1. In `handle_authenticated_input`, add chat sentinel check BEFORE the profile edit check:

Find the block that starts with:
```rust
// Profile edit mode needs raw input (spaces, Enter) -- check BEFORE trimming
if let Some(service_name) = &self.current_service {
    if service_name.starts_with("__profile_edit_") {
```

Add BEFORE it:
```rust
// Chat mode: process chat input
if let Some(service_name) = &self.current_service {
    if service_name == "__chat__" {
        // Update last_dm_sender if we received a DM
        // (This is a bit awkward but we need to track it somewhere)
        self.handle_chat_input(input).await;
        return;
    }
}
```

2. In the broadcast receiver task (inside enter_chat), update last_dm_sender tracking.

Actually, the receiver task can't update Session fields directly since it's a separate task.
Instead, we need to track this differently. The simplest approach:

Update the broadcast receiver in enter_chat to send a special JSON message that the input handler can check.

OR simpler: Just let the handle_chat_input look at incoming DMs by iterating recent messages.

Actually, the cleanest solution is to update last_dm_sender in handle_chat_input when we process a Direct message reply. But we don't have access to incoming messages there.

SIMPLEST solution: Update the receiver task to send a JSON signal with DM sender info, and have session.rs handle it.

Let's use a simpler approach: Store last_dm_sender in a shared Arc<RwLock<Option<String>>> that both the task and session can access.

Wait, that's overcomplicating. The receiver task already has my_handle. When it receives a Direct message where `to == my_handle`, it can... hmm, it can't update Session fields.

PRAGMATIC SOLUTION: Don't track last_dm_sender for now. Users must use /msg explicitly. /r can be added later with more complex state sharing if needed.

For now, modify ChatCommand::Reply handling to show an error:
```rust
ChatCommand::Reply(_text) => {
    let _ = self.tx.send(render_chat_error("Use /msg <handle> <message> to send direct messages")).await;
}
```

3. In `on_disconnect`, add chat cleanup before the profile edit cleanup:

Find the section that handles disconnect cleanup. Add:
```rust
// Exit chat if in chat mode
if let Some(service_name) = &self.current_service {
    if service_name == "__chat__" {
        // Cancel broadcast receiver
        if let Some(cancel) = self.chat_cancel.take() {
            cancel.cancel();
        }
        // Broadcast leave and cleanup
        if let AuthState::Authenticated { user_id, handle, .. } = &self.auth_state {
            self.state.chat_manager.broadcast(ChatMessage::Leave { handle: handle.clone() }).await;
            self.state.chat_manager.leave(*user_id).await;
        }
    }
}
```
  </action>
  <verify>cargo build --manifest-path backend/Cargo.toml</verify>
  <done>Chat mode integrated into session lifecycle</done>
</task>

</tasks>

<verification>
1. `cargo build --manifest-path backend/Cargo.toml` succeeds
2. `cargo test --manifest-path backend/Cargo.toml` passes
3. Manual test: Start server, connect two browser tabs, enter chat in both, send message, see it appear in both
4. Manual test: /quit returns to menu, other user sees leave announcement
5. Manual test: /who shows both users
6. Manual test: /me waves shows action format
</verification>

<success_criteria>
- User can enter chat mode (enter_chat called)
- User sees welcome message and join announcement
- Messages from other users appear in real-time via broadcast
- All slash commands work: /help, /who, /me, /msg, /page, /quit
- Exiting chat broadcasts leave announcement
- Disconnecting while in chat cleans up properly
</success_criteria>

<output>
After completion, create `.planning/phases/06-chat-real-time-communication/06-03-SUMMARY.md`
</output>
