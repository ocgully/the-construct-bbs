---
phase: 04-time-limits-user-lists
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - frontend/src/status-bar.ts
  - frontend/src/timer.ts
  - frontend/src/websocket.ts
  - frontend/src/main.ts
autonomous: true

must_haves:
  truths:
    - "Status bar visible at row 24 showing user name, online count, and time remaining"
    - "Status bar background changes to yellow at 5 minutes, red at 1 minute"
    - "Client-side countdown updates display per-minute normally, per-second in last minute"
    - "Timer JSON messages from server are intercepted and not written to terminal"
  artifacts:
    - path: "frontend/src/status-bar.ts"
      provides: "StatusBar class rendering ANSI status bar at row 24"
      contains: "class StatusBar"
    - path: "frontend/src/timer.ts"
      provides: "SessionTimer class with client-side countdown"
      contains: "class SessionTimer"
    - path: "frontend/src/websocket.ts"
      provides: "Timer and timeout JSON message handling"
      contains: "timer"
  key_links:
    - from: "frontend/src/websocket.ts"
      to: "frontend/src/timer.ts"
      via: "JSON message routing to timer update"
      pattern: "parsed\\.type.*timer"
    - from: "frontend/src/timer.ts"
      to: "frontend/src/status-bar.ts"
      via: "timer calls statusBar.update()"
      pattern: "statusBar\\.update"
    - from: "frontend/src/status-bar.ts"
      to: "xterm Terminal"
      via: "writes ANSI escape sequences to terminal"
      pattern: "terminal\\.write"
---

<objective>
Create the frontend status bar renderer and client-side countdown timer that displays session time remaining at the bottom of the terminal.

Purpose: The user needs a persistent, always-visible countdown of their remaining session time. The status bar at row 24 provides this with color-coded warnings (yellow at 5min, red at 1min). Client-side countdown reduces WebSocket traffic while maintaining visual accuracy.
Output: status-bar.ts (ANSI status bar renderer), timer.ts (client-side countdown), websocket.ts updates for timer message handling.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-time-limits-user-lists/04-CONTEXT.md
@.planning/phases/04-time-limits-user-lists/04-RESEARCH.md
@frontend/src/websocket.ts
@frontend/src/main.ts
@frontend/src/terminal.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Status Bar Renderer and Client-Side Timer</name>
  <files>
    frontend/src/status-bar.ts
    frontend/src/timer.ts
  </files>
  <action>
1. Create frontend/src/status-bar.ts:
   ```typescript
   import { Terminal } from '@xterm/xterm';

   export type WarningLevel = 'normal' | 'yellow' | 'red';

   export class StatusBar {
       private terminal: Terminal;
       private handle: string = '';
       private onlineCount: number = 0;
       private timeDisplay: string = '';
       private warningLevel: WarningLevel = 'normal';
       private visible: boolean = false;

       constructor(terminal: Terminal) {
           this.terminal = terminal;
       }

       /**
        * Update status bar content and re-render.
        */
       update(opts: {
           handle?: string;
           online?: number;
           timeDisplay?: string;
           warning?: WarningLevel;
       }) {
           if (opts.handle !== undefined) this.handle = opts.handle;
           if (opts.online !== undefined) this.onlineCount = opts.online;
           if (opts.timeDisplay !== undefined) this.timeDisplay = opts.timeDisplay;
           if (opts.warning !== undefined) this.warningLevel = opts.warning;
           this.render();
       }

       /**
        * Show the status bar (called after authentication).
        */
       show() {
           this.visible = true;
           this.render();
       }

       /**
        * Hide the status bar (called on disconnect/logout).
        */
       hide() {
           this.visible = false;
           // Clear row 24
           this.terminal.write('\x1b7\x1b[24;1H\x1b[2K\x1b8');
       }

       /**
        * Render the status bar at row 24 using ANSI escape codes.
        * Save cursor -> move to row 24 -> render bar -> restore cursor.
        */
       private render() {
           if (!this.visible) return;

           // Background and foreground colors based on warning level
           let bgColor: string;
           let fgColor: string;
           switch (this.warningLevel) {
               case 'red':
                   bgColor = '\x1b[41m';   // Red background
                   fgColor = '\x1b[97m';   // Bright white text
                   break;
               case 'yellow':
                   bgColor = '\x1b[43m';   // Yellow background
                   fgColor = '\x1b[30m';   // Black text
                   break;
               default:
                   bgColor = '\x1b[44m';   // Blue background (more visible than black)
                   fgColor = '\x1b[97m';   // Bright white text
                   break;
           }

           // Build the bar content
           const left = ` ${this.handle}`;
           const center = `Online: ${this.onlineCount}`;
           const right = `Time: ${this.timeDisplay} `;

           // Pad to fill 80 columns
           const contentLen = left.length + center.length + right.length;
           const totalWidth = 80;
           const leftPad = Math.floor((totalWidth - contentLen) / 3);
           const rightPad = totalWidth - left.length - leftPad - center.length - (totalWidth - left.length - leftPad - center.length - right.length);

           // Simple approach: left-aligned handle, centered online count, right-aligned time
           const spaceBetweenLeftCenter = Math.max(1, Math.floor((totalWidth - left.length - center.length - right.length) / 2));
           const spaceBetweenCenterRight = Math.max(1, totalWidth - left.length - spaceBetweenLeftCenter - center.length - right.length);

           const barContent = left +
               ' '.repeat(spaceBetweenLeftCenter) +
               center +
               ' '.repeat(spaceBetweenCenterRight) +
               right;

           // Pad or trim to exactly 80 chars
           const paddedBar = barContent.length < totalWidth
               ? barContent + ' '.repeat(totalWidth - barContent.length)
               : barContent.substring(0, totalWidth);

           // Write: save cursor, move to row 24 col 1, set colors, write bar, reset, restore cursor
           this.terminal.write(
               '\x1b7' +           // Save cursor position (DEC)
               '\x1b[24;1H' +     // Move to row 24, column 1
               bgColor + fgColor + // Set colors
               paddedBar +         // Bar content
               '\x1b[0m' +        // Reset colors
               '\x1b8'            // Restore cursor position (DEC)
           );
       }
   }
   ```

2. Create frontend/src/timer.ts:
   ```typescript
   import { StatusBar, WarningLevel } from './status-bar';

   export class SessionTimer {
       private statusBar: StatusBar;
       private remainingSeconds: number = 0;
       private intervalId: number | null = null;
       private isUnlimited: boolean = false;
       private lastUnit: string = 'min';

       constructor(statusBar: StatusBar) {
           this.statusBar = statusBar;
       }

       /**
        * Called when server sends a timer update.
        * Server sends per-minute updates normally, per-second in final minute.
        */
       updateFromServer(data: {
           remaining: number;
           unit: string;
           warning: string;
           handle: string;
           online: number;
       }) {
           if (data.unit === 'unlimited') {
               this.isUnlimited = true;
               this.statusBar.update({
                   handle: data.handle,
                   online: data.online,
                   timeDisplay: 'Unlimited',
                   warning: 'normal',
               });
               this.statusBar.show();
               return;
           }

           // Convert server value to seconds
           if (data.unit === 'min') {
               this.remainingSeconds = data.remaining * 60;
           } else {
               this.remainingSeconds = data.remaining;
           }

           const warning = data.warning as WarningLevel;

           // Update status bar
           this.statusBar.update({
               handle: data.handle,
               online: data.online,
               timeDisplay: this.formatTime(),
               warning: warning,
           });
           this.statusBar.show();

           // Restart client-side countdown with appropriate tick rate
           this.restartCountdown(data.unit === 'sec');
       }

       /**
        * Start or restart the client-side countdown.
        * Normal mode: tick per minute.
        * Last minute mode: tick per second.
        */
       private restartCountdown(perSecond: boolean) {
           // Clear existing interval to prevent duplicates
           if (this.intervalId !== null) {
               clearInterval(this.intervalId);
               this.intervalId = null;
           }

           if (this.isUnlimited) return;

           const tickMs = perSecond ? 1000 : 60000;
           const decrement = perSecond ? 1 : 60;

           this.intervalId = window.setInterval(() => {
               this.remainingSeconds -= decrement;
               if (this.remainingSeconds < 0) this.remainingSeconds = 0;

               // Determine warning level client-side
               const minutes = this.remainingSeconds / 60;
               let warning: WarningLevel = 'normal';
               if (minutes <= 1) {
                   warning = 'red';
               } else if (minutes <= 5) {
                   warning = 'yellow';
               }

               // Switch to per-second when hitting 1 minute (if not already)
               if (!perSecond && this.remainingSeconds <= 60 && this.remainingSeconds > 0) {
                   this.restartCountdown(true);
                   return;
               }

               this.statusBar.update({
                   timeDisplay: this.formatTime(),
                   warning: warning,
               });
           }, tickMs);
       }

       /**
        * Format remaining time for display.
        */
       private formatTime(): string {
           if (this.isUnlimited) return 'Unlimited';

           const totalSeconds = Math.max(0, this.remainingSeconds);
           const minutes = Math.floor(totalSeconds / 60);
           const seconds = totalSeconds % 60;

           if (minutes > 0) {
               return `${minutes}m`;
           } else {
               return `${seconds}s`;
           }
       }

       /**
        * Stop the timer (on disconnect/logout).
        */
       stop() {
           if (this.intervalId !== null) {
               clearInterval(this.intervalId);
               this.intervalId = null;
           }
           this.statusBar.hide();
       }

       /**
        * Update the online count (can be updated independently of timer).
        */
       updateOnlineCount(count: number) {
           this.statusBar.update({ online: count });
       }
   }
   ```
  </action>
  <verify>
    TypeScript files compile: run `npx tsc --noEmit` in frontend directory (or `npm run build` if available).
    No import errors in the new modules.
  </verify>
  <done>
    StatusBar class renders at row 24 with ANSI escape codes.
    Warning colors: normal=blue bg, yellow=yellow bg, red=red bg.
    SessionTimer handles server updates and maintains client-side countdown.
    Per-second ticking activates in final minute.
    Duplicate interval prevention (clearInterval before setInterval).
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Timer into WebSocket Message Handler</name>
  <files>
    frontend/src/websocket.ts
    frontend/src/main.ts
  </files>
  <action>
1. Modify frontend/src/websocket.ts to:
   - Accept a SessionTimer instance parameter (or export a setter)
   - Add JSON message handling for "timer", "timer_warning", and "timeout" types
   - The cleanest approach: change `connectWebSocket` to accept an options object:
     ```typescript
     export function connectWebSocket(terminal: Terminal, opts?: { timer?: SessionTimer }): WebSocket
     ```

   In the ws.onmessage handler, add cases BEFORE the existing JSON parse block (or within it):

   ```typescript
   if (parsed.type === 'timer') {
       // Update status bar timer
       if (opts?.timer) {
           opts.timer.updateFromServer(parsed);
       }
       return; // Don't write to terminal
   }
   if (parsed.type === 'timer_warning') {
       // Timer warning -- no action needed, status bar handles visuals
       // Could play a bell sound here if desired
       return;
   }
   if (parsed.type === 'timeout') {
       // Session timed out -- server will send goodbye screen as terminal text
       // Stop client timer
       if (opts?.timer) {
           opts.timer.stop();
       }
       return;
   }
   ```

   Also in the `ws.onclose` handler, stop the timer:
   ```typescript
   if (opts?.timer) {
       opts.timer.stop();
   }
   ```

   And in the logout handler, stop the timer:
   ```typescript
   if (parsed.type === 'logout') {
       localStorage.removeItem('bbs_session_token');
       if (opts?.timer) {
           opts.timer.stop();
       }
       return;
   }
   ```

2. Modify frontend/src/main.ts to:
   - Import StatusBar and SessionTimer
   - Create StatusBar instance with the terminal
   - Create SessionTimer instance with the StatusBar
   - Pass timer to connectWebSocket

   After the terminal is created (look for where connectWebSocket is called):
   ```typescript
   import { StatusBar } from './status-bar';
   import { SessionTimer } from './timer';

   // After terminal creation:
   const statusBar = new StatusBar(terminal);
   const timer = new SessionTimer(statusBar);
   connectWebSocket(terminal, { timer });
   ```

   The exact integration point depends on the current main.ts structure -- read it and wire in at the appropriate place. The key is that StatusBar and SessionTimer are instantiated once and shared with the WebSocket handler.
  </action>
  <verify>
    `npm run build` (or Vite build) succeeds in frontend directory.
    No TypeScript compilation errors.
    Frontend bundle generated.
  </verify>
  <done>
    WebSocket handler intercepts timer/timer_warning/timeout JSON messages.
    Timer messages do NOT render as text in terminal.
    StatusBar and SessionTimer created in main.ts and wired into WebSocket.
    Timer stops on logout, disconnect, and timeout.
  </done>
</task>

</tasks>

<verification>
- Frontend builds without errors
- Timer JSON messages are intercepted (not displayed as terminal text)
- Status bar renders at row 24 with correct ANSI positioning
- Timer countdown updates display appropriately
</verification>

<success_criteria>
- StatusBar renders persistent bar at terminal row 24
- Warning colors change: blue (normal), yellow (5min), red (1min)
- Client-side countdown ticks per-minute, switches to per-second at 1 minute
- All timer/timeout JSON messages intercepted by WebSocket handler
- Timer stops on logout/disconnect/timeout
</success_criteria>

<output>
After completion, create `.planning/phases/04-time-limits-user-lists/04-03-SUMMARY.md`
</output>
