---
phase: 04-time-limits-user-lists
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/src/connection/timer.rs
  - backend/src/connection/mod.rs
  - backend/src/services/goodbye.rs
  - backend/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Server can spawn per-session timer task that ticks per-minute and per-second in final minute"
    - "Timer task sends JSON messages with remaining time and warning level to client"
    - "Timer task cancellable via CancellationToken on clean quit"
    - "Timeout goodbye screen distinct from normal quit goodbye"
    - "Timer exposes expired and low_time flags via Arc<AtomicBool> for session polling"
  artifacts:
    - path: "backend/src/connection/timer.rs"
      provides: "SessionTimer struct and spawn_timer_task function"
      contains: "spawn_timer_task"
    - path: "backend/src/services/goodbye.rs"
      provides: "Timeout-specific goodbye render function"
      contains: "render_timeout_goodbye"
  key_links:
    - from: "backend/src/connection/timer.rs"
      to: "tokio::sync::mpsc::Sender"
      via: "sends timer JSON messages to client via tx channel"
      pattern: "tx\\.send"
    - from: "backend/src/connection/timer.rs"
      to: "tokio_util::sync::CancellationToken"
      via: "select! races timer tick against cancel signal"
      pattern: "cancel.*cancelled"
---

<objective>
Create the backend session timer task that enforces time limits and sends timer updates to clients, plus the timeout-specific goodbye screen.

Purpose: The timer task is the core enforcement mechanism for daily time limits. It ticks per-minute normally, switches to per-second in the final minute, sends JSON messages to the frontend for status bar display, and triggers timeout when time expires.
Output: timer.rs with SessionTimer, render_timeout_goodbye in goodbye.rs.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-time-limits-user-lists/04-CONTEXT.md
@.planning/phases/04-time-limits-user-lists/04-RESEARCH.md
@.planning/phases/04-time-limits-user-lists/04-01-SUMMARY.md
@backend/src/connection/mod.rs
@backend/src/services/goodbye.rs
@backend/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Session Timer Task with CancellationToken</name>
  <files>
    backend/src/connection/timer.rs
    backend/src/connection/mod.rs
    backend/Cargo.toml
  </files>
  <action>
1. Add `tokio-util` dependency to Cargo.toml:
   ```toml
   tokio-util = "0.7"
   ```
   CancellationToken is available in the base tokio-util crate with no feature flags required.

2. Create backend/src/connection/timer.rs:
   ```rust
   use std::sync::Arc;
   use std::sync::atomic::{AtomicBool, Ordering};
   use tokio::sync::mpsc;
   use tokio::time::{interval, Duration, MissedTickBehavior};
   use tokio_util::sync::CancellationToken;

   /// Represents a running session timer.
   /// Hold onto this struct -- dropping it won't cancel the task.
   /// Call cancel() to stop the timer (on clean quit).
   pub struct SessionTimer {
       cancel: CancellationToken,
       handle: tokio::task::JoinHandle<TimerResult>,
       /// Set to true when the timer expires (time reaches 0).
       /// Polled by session to trigger timeout sequence.
       expired: Arc<AtomicBool>,
       /// Set to true when remaining time <= 1 minute.
       /// Polled by session to trigger time bank withdrawal prompt.
       low_time: Arc<AtomicBool>,
   }

   /// Result of the timer task completing.
   #[derive(Debug, Clone, PartialEq)]
   pub enum TimerResult {
       /// Time expired -- user should be timed out
       Expired,
       /// Timer was cancelled (user quit normally)
       Cancelled,
   }

   impl SessionTimer {
       /// Spawn a new session timer task.
       ///
       /// - `tx`: Channel to send timer JSON updates to the client
       /// - `remaining_minutes`: How many minutes the user has left today
       /// - `handle`: User's handle (for status bar)
       /// - `users_online`: Number of users currently online (for status bar)
       ///
       /// The timer sends JSON messages of the form:
       /// { "type": "timer", "remaining": <minutes_or_seconds>, "unit": "min"|"sec", "warning": "normal"|"yellow"|"red", "handle": "...", "online": N }
       ///
       /// Timer ticks per-minute normally. In the final minute, switches to per-second.
       /// When remaining reaches 0, sends { "type": "timeout" } and returns TimerResult::Expired.
       pub fn spawn(
           tx: mpsc::Sender<String>,
           remaining_minutes: i64,
           handle: String,
           users_online: usize,
       ) -> Self {
           let cancel = CancellationToken::new();
           let cancel_clone = cancel.clone();
           let expired = Arc::new(AtomicBool::new(false));
           let expired_clone = expired.clone();
           let low_time = Arc::new(AtomicBool::new(false));
           let low_time_clone = low_time.clone();

           let handle_task = tokio::spawn(async move {
               run_timer(tx, remaining_minutes, handle, users_online, cancel_clone, expired_clone, low_time_clone).await
           });

           Self {
               cancel,
               handle: handle_task,
               expired,
               low_time,
           }
       }

       /// Cancel the timer (called on clean quit).
       pub fn cancel(&self) {
           self.cancel.cancel();
       }

       /// Wait for the timer to complete and get the result.
       pub async fn wait(self) -> TimerResult {
           match self.handle.await {
               Ok(result) => result,
               Err(_) => TimerResult::Cancelled, // Task panicked or was aborted
           }
       }

       /// Check if the timer is still running.
       pub fn is_running(&self) -> bool {
           !self.handle.is_finished()
       }

       /// Check if the timer has expired (time reached 0).
       /// Returns true once and stays true.
       pub fn is_expired(&self) -> bool {
           self.expired.load(Ordering::Relaxed)
       }

       /// Check if remaining time is <= 1 minute.
       /// Used by session to trigger time bank withdrawal prompt.
       pub fn is_low_time(&self) -> bool {
           self.low_time.load(Ordering::Relaxed)
       }
   }

   async fn run_timer(
       tx: mpsc::Sender<String>,
       remaining_minutes: i64,
       handle: String,
       users_online: usize,
       cancel: CancellationToken,
       expired_flag: Arc<AtomicBool>,
       low_time_flag: Arc<AtomicBool>,
   ) -> TimerResult {
       if remaining_minutes <= 0 {
           // Unlimited time (sysop) -- still send initial status but never expire
           let msg = serde_json::json!({
               "type": "timer",
               "remaining": 0,
               "unit": "unlimited",
               "warning": "normal",
               "handle": handle,
               "online": users_online
           });
           let _ = tx.send(msg.to_string()).await;

           // Just wait for cancellation
           cancel.cancelled().await;
           return TimerResult::Cancelled;
       }

       let mut remaining = remaining_minutes;
       let mut ticker = interval(Duration::from_secs(60));
       ticker.set_missed_tick_behavior(MissedTickBehavior::Skip);

       // Send initial time update
       let warning = get_warning_level(remaining, false);
       let msg = serde_json::json!({
           "type": "timer",
           "remaining": remaining,
           "unit": "min",
           "warning": warning,
           "handle": handle,
           "online": users_online
       });
       let _ = tx.send(msg.to_string()).await;

       // Consume the first immediate tick
       ticker.tick().await;

       // Per-minute countdown
       loop {
           tokio::select! {
               _ = ticker.tick() => {
                   remaining -= 1;

                   if remaining <= 1 {
                       // Signal low time for session to offer bank withdrawal
                       low_time_flag.store(true, Ordering::Relaxed);
                       // Switch to per-second countdown for final minute
                       break;
                   }

                   let warning = get_warning_level(remaining, false);
                   let msg = serde_json::json!({
                       "type": "timer",
                       "remaining": remaining,
                       "unit": "min",
                       "warning": warning,
                       "handle": handle,
                       "online": users_online
                   });
                   let _ = tx.send(msg.to_string()).await;

                   // Send special warning messages at 5-min and 1-min marks
                   if remaining == 5 {
                       let warn_msg = serde_json::json!({
                           "type": "timer_warning",
                           "minutes": 5
                       });
                       let _ = tx.send(warn_msg.to_string()).await;
                   }
               }
               _ = cancel.cancelled() => {
                   return TimerResult::Cancelled;
               }
           }
       }

       // Final minute: per-second countdown
       let mut remaining_secs: i64 = remaining * 60; // Convert remaining minutes to seconds
       let mut sec_ticker = interval(Duration::from_secs(1));
       sec_ticker.set_missed_tick_behavior(MissedTickBehavior::Skip);

       // Send 1-minute warning
       let warn_msg = serde_json::json!({
           "type": "timer_warning",
           "minutes": 1
       });
       let _ = tx.send(warn_msg.to_string()).await;

       // Consume first immediate tick
       sec_ticker.tick().await;

       loop {
           tokio::select! {
               _ = sec_ticker.tick() => {
                   remaining_secs -= 1;

                   let msg = serde_json::json!({
                       "type": "timer",
                       "remaining": remaining_secs,
                       "unit": "sec",
                       "warning": "red",
                       "handle": handle,
                       "online": users_online
                   });
                   let _ = tx.send(msg.to_string()).await;

                   if remaining_secs <= 0 {
                       // Time expired -- set flag and send timeout signal
                       expired_flag.store(true, Ordering::Relaxed);
                       let timeout_msg = serde_json::json!({
                           "type": "timeout"
                       });
                       let _ = tx.send(timeout_msg.to_string()).await;
                       return TimerResult::Expired;
                   }
               }
               _ = cancel.cancelled() => {
                   return TimerResult::Cancelled;
               }
           }
       }
   }

   fn get_warning_level(remaining_minutes: i64, _is_seconds: bool) -> &'static str {
       if remaining_minutes <= 1 {
           "red"
       } else if remaining_minutes <= 5 {
           "yellow"
       } else {
           "normal"
       }
   }
   ```

3. Add `pub mod timer;` to backend/src/connection/mod.rs.
  </action>
  <verify>
    `cargo check` passes with the new timer module.
  </verify>
  <done>
    SessionTimer struct exists with spawn(), cancel(), wait(), is_running(), is_expired(), is_low_time() methods.
    Timer sends JSON updates per-minute (switching to per-second in final minute).
    CancellationToken allows clean cancellation on quit.
    TimerResult enum distinguishes Expired vs Cancelled.
    expired Arc<AtomicBool> set when time reaches 0 (polled by session for timeout).
    low_time Arc<AtomicBool> set when remaining <= 1 minute (polled by session for bank withdrawal prompt).
  </done>
</task>

<task type="auto">
  <name>Task 2: Timeout Goodbye Screen</name>
  <files>
    backend/src/services/goodbye.rs
  </files>
  <action>
1. Add a `render_timeout_goodbye` function to backend/src/services/goodbye.rs:
   This renders a distinct goodbye screen for users who ran out of time (not the normal quit goodbye).

   The function should:
   - Accept handle: &str, session_minutes: i64, total_calls: i64, total_time: i64
   - Clear screen first
   - Use CP437 double-line box drawing (same aesthetic as existing goodbye)
   - Title: "TIME EXPIRED" instead of "GOODBYE"
   - Color scheme: LightRed border (warning feel) instead of LightCyan
   - Body text: "Your daily time has expired." / "Session time: Xm" / "Come back tomorrow for more time!"
   - Include user stats (total calls, total time) same as normal goodbye
   - End with "NO CARRIER" disconnect message (same as normal quit)

   Follow the exact same rendering pattern as the existing `render_goodbye` function but with:
   - Different title text
   - Different border color (LightRed)
   - Different body message about time expiration
   - Same NO CARRIER ending
  </action>
  <verify>
    `cargo check` passes.
    The render_timeout_goodbye function exists and returns a String.
  </verify>
  <done>
    render_timeout_goodbye function renders ANSI art timeout screen distinct from normal goodbye.
    Uses LightRed border, "TIME EXPIRED" title, daily time messaging.
    Includes NO CARRIER disconnect message.
  </done>
</task>

</tasks>

<verification>
- `cargo check` compiles with timer.rs module and timeout goodbye
- Timer JSON message format is documented and consistent
- CancellationToken integration compiles
- tokio-util dependency added correctly
</verification>

<success_criteria>
- SessionTimer spawns async task with per-minute ticks
- Timer switches to per-second in final minute
- JSON messages include remaining time, unit, warning level
- CancellationToken cancels timer on quit
- expired and low_time flags available for session polling
- Timeout goodbye screen renders with time-expired messaging
</success_criteria>

<output>
After completion, create `.planning/phases/04-time-limits-user-lists/04-02-SUMMARY.md`
</output>
