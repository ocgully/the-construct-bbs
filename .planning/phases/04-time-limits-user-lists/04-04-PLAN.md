---
phase: 04-time-limits-user-lists
plan: 04
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/src/services/who.rs
  - backend/src/services/last_callers.rs
  - backend/src/services/mod.rs
autonomous: true

must_haves:
  truths:
    - "User can view who's currently online with handle, node, activity, and idle time"
    - "User can view last callers list with handle, login time, and session duration"
    - "Both displays use ANSI art with BBS aesthetic"
  artifacts:
    - path: "backend/src/services/who.rs"
      provides: "Who's Online service implementing Service trait"
      contains: "impl Service for WhosOnline"
    - path: "backend/src/services/last_callers.rs"
      provides: "Last Callers service implementing Service trait"
      contains: "impl Service for LastCallers"
  key_links:
    - from: "backend/src/services/who.rs"
      to: "backend/src/connection/node_manager.rs"
      via: "queries active nodes for online user list"
      pattern: "get_active_nodes_full"
    - from: "backend/src/services/last_callers.rs"
      to: "backend/src/db/session_history.rs"
      via: "queries session_history for recent callers"
      pattern: "get_last_callers"
---

<objective>
Create the Who's Online and Last Callers services that display active and recent users in ANSI-formatted lists.

Purpose: Users need to see who else is on the BBS (core social feature) and who has called recently (engagement and community feel). Both are standard BBS features that create the sense of a living, shared space.
Output: who.rs (Who's Online service), last_callers.rs (Last Callers service).
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-time-limits-user-lists/04-CONTEXT.md
@.planning/phases/04-time-limits-user-lists/04-RESEARCH.md
@.planning/phases/04-time-limits-user-lists/04-01-SUMMARY.md
@backend/src/services/mod.rs
@backend/src/connection/node_manager.rs
@backend/src/terminal/ansi.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Who's Online Service</name>
  <files>
    backend/src/services/who.rs
    backend/src/services/mod.rs
  </files>
  <action>
1. Create backend/src/services/who.rs implementing the Service trait:

   The Who's Online service displays a table of currently connected users. Since services don't have async access to AppState directly (they receive &mut dyn SessionIO), this service needs a different approach. Looking at the existing service pattern, services use SessionIO::write/writeln for output.

   IMPORTANT: The Service trait methods are synchronous (fn, not async fn). They can't call async NodeManager methods directly. Two approaches:
   a) Pre-load the data before calling on_enter (like how session.rs handles profile view)
   b) Make WhosOnline a struct that holds pre-loaded data

   Best approach: Follow the same pattern as profile view -- don't use the Service trait. Instead, create a standalone render function that the session calls directly (like render_profile_card). The session has access to AppState and can call async NodeManager methods.

   Create render functions:
   ```rust
   use crate::connection::node_manager::NodeInfo;
   use crate::terminal::{AnsiWriter, Color};

   /// Render the Who's Online display as ANSI art.
   ///
   /// Shows a table with columns: Node | Handle | Activity | Idle
   /// Uses CP437 box-drawing characters for the BBS aesthetic.
   pub fn render_whos_online(nodes: &[(usize, NodeInfo)]) -> String {
       let mut w = AnsiWriter::new();
       let border_color = Color::LightCyan;
       let header_color = Color::Yellow;
       let label_color = Color::LightGray;
       let value_color = Color::White;

       // Clear screen
       w.clear_screen();

       // Title
       w.set_fg(header_color);
       w.bold();
       w.writeln("  WHO'S ONLINE");
       w.reset_color();
       w.writeln("");

       // Table header with box drawing
       w.set_fg(border_color);
       w.writeln(&format!("\u{2554}{}\u{2566}{}\u{2566}{}\u{2566}{}\u{2557}",
           "\u{2550}".repeat(6),   // Node
           "\u{2550}".repeat(20),  // Handle
           "\u{2550}".repeat(30),  // Activity
           "\u{2550}".repeat(20),  // Idle
       ));

       // Header row
       w.set_fg(border_color);
       w.write_str("\u{2551}");
       w.set_fg(header_color);
       w.bold();
       w.write_str(&format!("{:^6}", "Node"));
       w.reset_color();
       w.set_fg(border_color);
       w.write_str("\u{2551}");
       w.set_fg(header_color);
       w.bold();
       w.write_str(&format!("{:<20}", " Handle"));
       w.reset_color();
       w.set_fg(border_color);
       w.write_str("\u{2551}");
       w.set_fg(header_color);
       w.bold();
       w.write_str(&format!("{:<30}", " Activity"));
       w.reset_color();
       w.set_fg(border_color);
       w.write_str("\u{2551}");
       w.set_fg(header_color);
       w.bold();
       w.write_str(&format!("{:<20}", " Idle"));
       w.reset_color();
       w.set_fg(border_color);
       w.writeln("\u{2551}");

       // Header separator
       w.writeln(&format!("\u{2560}{}\u{256C}{}\u{256C}{}\u{256C}{}\u{2563}",
           "\u{2550}".repeat(6),
           "\u{2550}".repeat(20),
           "\u{2550}".repeat(30),
           "\u{2550}".repeat(20),
       ));

       // Data rows
       if nodes.is_empty() {
           w.set_fg(border_color);
           w.write_str("\u{2551}");
           w.set_fg(label_color);
           w.write_str(&format!("{:^78}", "No users online"));
           w.set_fg(border_color);
           w.writeln("\u{2551}");
       } else {
           for (node_id, info) in nodes {
               // Calculate idle time from last_input
               let idle = chrono::Utc::now() - info.last_input;
               let idle_str = format_idle_time(idle);

               w.set_fg(border_color);
               w.write_str("\u{2551}");
               w.set_fg(value_color);
               w.bold();
               w.write_str(&format!("{:^6}", node_id));
               w.reset_color();
               w.set_fg(border_color);
               w.write_str("\u{2551}");
               w.set_fg(value_color);
               w.write_str(&format!(" {:<19}", truncate(&info.handle, 19)));
               w.set_fg(border_color);
               w.write_str("\u{2551}");
               w.set_fg(label_color);
               w.write_str(&format!(" {:<29}", truncate(&info.current_activity, 29)));
               w.set_fg(border_color);
               w.write_str("\u{2551}");
               w.set_fg(label_color);
               w.write_str(&format!(" {:<19}", idle_str));
               w.set_fg(border_color);
               w.writeln("\u{2551}");
           }
       }

       // Bottom border
       w.set_fg(border_color);
       w.writeln(&format!("\u{255A}{}\u{2569}{}\u{2569}{}\u{2569}{}\u{255D}",
           "\u{2550}".repeat(6),
           "\u{2550}".repeat(20),
           "\u{2550}".repeat(30),
           "\u{2550}".repeat(20),
       ));

       w.reset_color();
       w.writeln("");
       w.set_fg(Color::LightCyan);
       w.writeln("  Press any key to return...");
       w.reset_color();

       w.flush()
   }

   fn format_idle_time(duration: chrono::Duration) -> String {
       let secs = duration.num_seconds();
       if secs < 60 { return format!("{}s", secs); }
       let mins = secs / 60;
       if mins < 60 { return format!("{}m", mins); }
       let hours = mins / 60;
       format!("{}h {}m", hours, mins % 60)
   }

   fn truncate(s: &str, max: usize) -> String {
       if s.len() <= max { s.to_string() }
       else { format!("{}...", &s[..max.saturating_sub(3)]) }
   }
   ```

   NOTE: The table width is 6+20+30+20+4(borders) = 80 columns. Adjust if needed to fit exactly 80 columns.

2. Add `pub mod who;` to backend/src/services/mod.rs.
  </action>
  <verify>
    `cargo check` passes with the new who.rs module.
  </verify>
  <done>
    render_whos_online function exists, accepts Vec of (node_id, NodeInfo).
    Displays table with Node, Handle, Activity, Idle columns.
    Uses CP437 box-drawing and CGA colors.
    Handles empty state ("No users online").
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Last Callers Service</name>
  <files>
    backend/src/services/last_callers.rs
    backend/src/services/mod.rs
  </files>
  <action>
1. Create backend/src/services/last_callers.rs:

   Like Who's Online, this is a render function called by the session (not a Service trait impl) because it needs async DB access.

   ```rust
   use crate::db::session_history::SessionHistoryEntry;
   use crate::terminal::{AnsiWriter, Color};

   /// Render the Last Callers display as ANSI art.
   ///
   /// Shows a table with columns: # | Handle | Date/Time | Duration
   /// Entries are sorted by most recent first.
   pub fn render_last_callers(entries: &[SessionHistoryEntry]) -> String {
       let mut w = AnsiWriter::new();
       let border_color = Color::LightCyan;
       let header_color = Color::Yellow;
       let label_color = Color::LightGray;
       let value_color = Color::White;

       // Clear screen
       w.clear_screen();

       // Title
       w.set_fg(header_color);
       w.bold();
       w.writeln("  LAST CALLERS");
       w.reset_color();
       w.writeln("");

       // Table header
       w.set_fg(border_color);
       w.writeln(&format!("\u{2554}{}\u{2566}{}\u{2566}{}\u{2566}{}\u{2557}",
           "\u{2550}".repeat(4),   // #
           "\u{2550}".repeat(22),  // Handle
           "\u{2550}".repeat(34),  // Date/Time
           "\u{2550}".repeat(16),  // Duration
       ));

       // Header labels
       w.set_fg(border_color);
       w.write_str("\u{2551}");
       w.set_fg(header_color);
       w.bold();
       w.write_str(&format!("{:^4}", "#"));
       w.reset_color();
       w.set_fg(border_color);
       w.write_str("\u{2551}");
       w.set_fg(header_color);
       w.bold();
       w.write_str(&format!("{:<22}", " Handle"));
       w.reset_color();
       w.set_fg(border_color);
       w.write_str("\u{2551}");
       w.set_fg(header_color);
       w.bold();
       w.write_str(&format!("{:<34}", " Date/Time"));
       w.reset_color();
       w.set_fg(border_color);
       w.write_str("\u{2551}");
       w.set_fg(header_color);
       w.bold();
       w.write_str(&format!("{:<16}", " Duration"));
       w.reset_color();
       w.set_fg(border_color);
       w.writeln("\u{2551}");

       // Separator
       w.writeln(&format!("\u{2560}{}\u{256C}{}\u{256C}{}\u{256C}{}\u{2563}",
           "\u{2550}".repeat(4),
           "\u{2550}".repeat(22),
           "\u{2550}".repeat(34),
           "\u{2550}".repeat(16),
       ));

       // Data rows
       if entries.is_empty() {
           w.set_fg(border_color);
           w.write_str("\u{2551}");
           w.set_fg(label_color);
           // Inner width = 4+22+34+16+3(inner borders) = 79. With outer borders = 81. Need to adjust.
           // Actually: 4+22+34+16 = 76 + 3 inner borders + 2 outer = 81... Let me adjust column widths.
           // Use: 4 + 20 + 34 + 16 = 74 + 3 + 2 = 79. Still off.
           // Better: make total inner = 76 (78 with outer borders = 80)
           // 4 + 20 + 34 + 18 = 76 inner + 3 inner borders + 2 outer = 81. Still 81.
           // Actually: columns are 4, 22, 34, 16 = 76 data + 5 border chars (4 inner + 0? No.)
           // Borders: | col1 | col2 | col3 | col4 | = 5 border chars + 76 data = 81. Too wide.
           // Fix: 4 + 20 + 32 + 16 = 72 + 5 borders = 77. Still need 80.
           // Let's do: 4 + 20 + 34 + 17 = 75 + 5 = 80. Yes!
           w.write_str(&format!("{:^75}", "No callers recorded yet"));
           w.set_fg(border_color);
           w.writeln("\u{2551}");
       } else {
           for (i, entry) in entries.iter().enumerate() {
               let duration_str = format_duration(entry.duration_minutes);

               w.set_fg(border_color);
               w.write_str("\u{2551}");
               w.set_fg(value_color);
               w.bold();
               w.write_str(&format!("{:>3} ", i + 1));
               w.reset_color();
               w.set_fg(border_color);
               w.write_str("\u{2551}");
               w.set_fg(value_color);
               w.write_str(&format!(" {:<19}", truncate(&entry.handle, 19)));
               w.set_fg(border_color);
               w.write_str("\u{2551}");
               w.set_fg(label_color);
               w.write_str(&format!(" {:<33}", truncate(&entry.login_time, 33)));
               w.set_fg(border_color);
               w.write_str("\u{2551}");
               w.set_fg(label_color);
               w.write_str(&format!(" {:<16}", duration_str));
               w.set_fg(border_color);
               w.writeln("\u{2551}");
           }
       }

       // Bottom border
       w.set_fg(border_color);
       w.writeln(&format!("\u{255A}{}\u{2569}{}\u{2569}{}\u{2569}{}\u{255D}",
           "\u{2550}".repeat(4),
           "\u{2550}".repeat(20),
           "\u{2550}".repeat(34),
           "\u{2550}".repeat(17),
       ));

       w.reset_color();
       w.writeln("");
       w.set_fg(Color::LightCyan);
       w.writeln("  Press any key to return...");
       w.reset_color();

       w.flush()
   }

   fn format_duration(minutes: i32) -> String {
       if minutes < 60 {
           format!("{}m", minutes)
       } else {
           format!("{}h {}m", minutes / 60, minutes % 60)
       }
   }

   fn truncate(s: &str, max: usize) -> String {
       if s.len() <= max { s.to_string() }
       else { format!("{}...", &s[..max.saturating_sub(3)]) }
   }
   ```

   IMPORTANT: Carefully calculate column widths so the total width (data columns + border characters) equals exactly 80. The border chars are: 2 outer + (N-1) inner separators. For 4 columns: 2 outer + 3 inner = 5 border chars. So data width = 75. Distribute as: 4 + 20 + 34 + 17 = 75. Verify this during implementation and adjust as needed.

2. Add `pub mod last_callers;` to backend/src/services/mod.rs (if not already added for who.rs).
  </action>
  <verify>
    `cargo check` passes with the new last_callers.rs module.
  </verify>
  <done>
    render_last_callers function exists, accepts Vec of SessionHistoryEntry.
    Displays table with #, Handle, Date/Time, Duration columns.
    Uses CP437 box-drawing and CGA colors.
    Total table width = 80 columns.
    Handles empty state.
  </done>
</task>

</tasks>

<verification>
- `cargo check` passes with both new service modules
- Who's Online render function accepts NodeInfo data
- Last Callers render function accepts SessionHistoryEntry data
- Both use consistent ANSI art style with box-drawing borders
</verification>

<success_criteria>
- Who's Online displays Node, Handle, Activity, Idle columns
- Last Callers displays #, Handle, Date/Time, Duration columns
- Both fit within 80-column terminal width
- Both handle empty state gracefully
- CP437 box-drawing characters used consistently
</success_criteria>

<output>
After completion, create `.planning/phases/04-time-limits-user-lists/04-04-SUMMARY.md`
</output>
