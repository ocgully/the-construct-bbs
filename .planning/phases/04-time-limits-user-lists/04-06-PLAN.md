---
phase: 04-time-limits-user-lists
plan: 06
type: execute
wave: 3
depends_on: ["04-01", "04-02", "04-03", "04-04", "04-05"]
files_modified:
  - backend/src/websocket/session.rs
  - backend/src/websocket/mod.rs
autonomous: true

must_haves:
  truths:
    - "Timer starts when user authenticates and counts down remaining daily time"
    - "Daily time resets on login if midnight boundary crossed (auto-bank unused time)"
    - "User is gracefully logged out when time expires with timeout goodbye screen"
    - "Time bank withdrawal prompted at 1-minute warning"
    - "Who's Online, Last Callers, and User Lookup commands work from main menu"
    - "Session history recorded on login and updated on logout"
    - "Timer cancels cleanly on normal quit (no double cleanup)"
    - "NodeManager activity updated when user navigates menus or enters services"
  artifacts:
    - path: "backend/src/websocket/session.rs"
      provides: "Full timer lifecycle integration, timeout handling, command routing"
      contains: "SessionTimer"
    - path: "backend/src/websocket/mod.rs"
      provides: "Timer task coordination with send/recv tasks"
      contains: "timer"
  key_links:
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/connection/timer.rs"
      via: "spawns SessionTimer on authentication"
      pattern: "SessionTimer::spawn"
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/db/session_history.rs"
      via: "inserts session history on login, updates on logout"
      pattern: "insert_session_history"
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/db/user.rs"
      via: "checks daily reset and banks time on login"
      pattern: "check_daily_reset"
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/services/who.rs"
      via: "renders Who's Online from NodeManager data"
      pattern: "render_whos_online"
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/services/last_callers.rs"
      via: "renders Last Callers from session_history query"
      pattern: "render_last_callers"
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/services/user_profile.rs"
      via: "renders user lookup prompt and profile card"
      pattern: "render_lookup_prompt"
    - from: "backend/src/websocket/mod.rs"
      to: "backend/src/connection/timer.rs"
      via: "timer expiration triggers timeout sequence"
      pattern: "TimerResult::Expired"
---

<objective>
Wire all Phase 4 features into the session lifecycle: timer start/stop, daily reset, timeout enforcement, time banking, session history, and menu command routing for Who's Online, Last Callers, and User Lookup.

Purpose: This is the integration plan that connects all the individual Phase 4 components into a working system. Without this, the timer exists but doesn't start, the services exist but aren't reachable, and time banking exists but isn't triggered.
Output: Fully integrated timer lifecycle in session.rs, command routing for all Phase 4 features, session history tracking.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-time-limits-user-lists/04-CONTEXT.md
@.planning/phases/04-time-limits-user-lists/04-RESEARCH.md
@.planning/phases/04-time-limits-user-lists/04-01-SUMMARY.md
@.planning/phases/04-time-limits-user-lists/04-02-SUMMARY.md
@.planning/phases/04-time-limits-user-lists/04-03-SUMMARY.md
@.planning/phases/04-time-limits-user-lists/04-04-SUMMARY.md
@.planning/phases/04-time-limits-user-lists/04-05-SUMMARY.md
@backend/src/websocket/session.rs
@backend/src/websocket/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Timer Lifecycle and Session History Integration</name>
  <files>
    backend/src/websocket/session.rs
  </files>
  <action>
1. Add new fields to the Session struct:
   ```rust
   /// Session timer for time limit enforcement
   session_timer: Option<crate::connection::timer::SessionTimer>,
   /// Session history ID for updating logout time
   session_history_id: Option<i64>,
   /// Input buffer for user lookup handle entry
   lookup_input: Option<String>,
   ```
   Initialize all to None in Session::new().

2. Add timer start logic -- create a helper method:
   ```rust
   async fn start_session_timer(&mut self, user_id: i64, user_level: &str) {
       let pool = &self.state.db_pool;
       let config = &self.state.config;

       // Check daily reset
       if let Ok(needs_reset) = crate::db::user::check_daily_reset(pool, user_id).await {
           if needs_reset {
               let time_cfg = config.time_limits.get_time_config(user_level);
               let _ = crate::db::user::reset_daily_time(
                   pool, user_id, time_cfg.daily_minutes, time_cfg.time_bank_cap
               ).await;
           }
       }

       // Get remaining time
       let time_cfg = config.time_limits.get_time_config(user_level);
       if time_cfg.daily_minutes == 0 {
           // Unlimited time (sysop) -- still start timer for status bar display
           let (active, _) = self.state.node_manager.get_status().await;
           let handle = match &self.auth_state {
               AuthState::Authenticated { handle, .. } => handle.clone(),
               _ => "Unknown".to_string(),
           };
           let timer = crate::connection::timer::SessionTimer::spawn(
               self.tx.clone(), 0, handle, active,
           );
           self.session_timer = Some(timer);
           return;
       }

       let (daily_used, _banked, _) = match crate::db::user::get_user_time_info(pool, user_id).await {
           Ok(info) => info,
           Err(_) => (0, 0, 0),
       };

       let remaining = (time_cfg.daily_minutes - daily_used).max(0);

       // Check if user has any time left (daily + banked)
       if remaining <= 0 {
           // Check banked time
           let banked = match crate::db::user::get_user_time_info(pool, user_id).await {
               Ok((_, b, _)) => b,
               Err(_) => 0,
           };
           if banked <= 0 {
               // No time available at all -- disconnect
               let mut w = AnsiWriter::new();
               w.set_fg(Color::LightRed);
               w.bold();
               w.writeln("");
               w.writeln("Your daily time has expired and you have no banked time.");
               w.writeln("Please try again after midnight.");
               w.reset_color();
               let _ = self.tx.send(w.flush()).await;
               tokio::time::sleep(Duration::from_secs(3)).await;
               self.disconnecting = true;
               return;
           }
           // Has banked time -- withdraw it
           let withdrawn = crate::db::user::withdraw_banked_time(pool, user_id, banked).await.unwrap_or(0);
           let mut w = AnsiWriter::new();
           w.set_fg(Color::Yellow);
           w.writeln(&format!("Using {} minutes of banked time.", withdrawn));
           w.reset_color();
           let _ = self.tx.send(w.flush()).await;
           // remaining is now the withdrawn amount
           let remaining = withdrawn;
           let (active, _) = self.state.node_manager.get_status().await;
           let handle = match &self.auth_state {
               AuthState::Authenticated { handle, .. } => handle.clone(),
               _ => "Unknown".to_string(),
           };
           let timer = crate::connection::timer::SessionTimer::spawn(
               self.tx.clone(), remaining, handle, active,
           );
           self.session_timer = Some(timer);
           return;
       }

       let (active, _) = self.state.node_manager.get_status().await;
       let handle = match &self.auth_state {
           AuthState::Authenticated { handle, .. } => handle.clone(),
           _ => "Unknown".to_string(),
       };
       let timer = crate::connection::timer::SessionTimer::spawn(
           self.tx.clone(), remaining, handle, active,
       );
       self.session_timer = Some(timer);
   }
   ```

3. Call start_session_timer after authentication in ALL three paths:
   - After login success (in handle_login_input, LoginResult::Success)
   - After session resume (in handle_awaiting_auth, valid token path)
   - After registration auto-login (in handle_registration_input, Complete)

   In each path, AFTER setting auth_state to Authenticated and creating menu_session, add:
   ```rust
   // Start session timer
   self.start_session_timer(user_id, &user_level).await;

   // Record session history
   if let Ok(history_id) = crate::db::session_history::insert_session_history(
       &self.state.db_pool, user_id, &handle
   ).await {
       self.session_history_id = Some(history_id);
   }
   ```

4. Cancel timer on clean quit -- in handle_quit(), BEFORE the existing cleanup:
   ```rust
   // Cancel session timer
   if let Some(timer) = self.session_timer.take() {
       timer.cancel();
   }
   ```

   Also update session history on quit:
   ```rust
   // Update session history with logout time
   if let Some(history_id) = self.session_history_id {
       let _ = crate::db::session_history::update_session_history_logout(
           &self.state.db_pool, history_id, session_minutes as i32
       ).await;
   }

   // Update daily time used
   let _ = crate::db::user::update_daily_time_used(
       &self.state.db_pool, *user_id, session_minutes
   ).await;
   ```

5. Cancel timer on disconnect -- in on_disconnect(), add:
   ```rust
   // Cancel session timer
   if let Some(timer) = self.session_timer.take() {
       timer.cancel();
   }

   // Update session history
   if let Some(history_id) = self.session_history_id {
       let session_secs = if let AuthState::Authenticated { login_time, .. } = &self.auth_state {
           login_time.elapsed().as_secs()
       } else { 0 };
       let session_minutes = (session_secs / 60) as i32;
       let _ = crate::db::session_history::update_session_history_logout(
           &self.state.db_pool, history_id, session_minutes
       ).await;
   }

   // Update daily time used
   if let AuthState::Authenticated { user_id, login_time, .. } = &self.auth_state {
       let session_minutes = (login_time.elapsed().as_secs() / 60) as i64;
       let _ = crate::db::user::update_daily_time_used(
           &self.state.db_pool, *user_id, session_minutes
       ).await;
   }
   ```

6. Update NodeManager activity when navigating -- in handle_authenticated_input:
   - When entering a service: `self.state.node_manager.update_activity(node_id, &format!("In {}", service_name)).await;`
   - When returning to menu: `self.state.node_manager.update_activity(node_id, "Main Menu").await;`
   - On any input: `self.state.node_manager.update_last_input(node_id).await;` (at the top of handle_authenticated_input)
  </action>
  <verify>
    `cargo check` passes with all new session integration code.
  </verify>
  <done>
    Session timer starts on authentication (all 3 paths).
    Daily time checked and reset on login if midnight crossed.
    Session history recorded on login, updated on logout/disconnect.
    Timer cancelled on quit and disconnect.
    Daily time usage tracked.
    NodeManager activity updated during navigation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Command Routing, Timeout Handling, and Time Bank Withdrawal</name>
  <files>
    backend/src/websocket/session.rs
    backend/src/websocket/mod.rs
  </files>
  <action>
1. Add command routing in handle_authenticated_input for Phase 4 commands.

   In the MenuAction::ExecuteCommand match block (where "quit" and "profile" are handled), add:

   ```rust
   "whos_online" => {
       let _ = self.tx.send(format!("{}", ch)).await;
       self.handle_whos_online().await;
       return;
   }
   "last_callers" => {
       let _ = self.tx.send(format!("{}", ch)).await;
       self.handle_last_callers().await;
       return;
   }
   "user_lookup" => {
       let _ = self.tx.send(format!("{}", ch)).await;
       self.handle_user_lookup_start().await;
       return;
   }
   ```

2. Implement the handler methods:

   ```rust
   /// Handle Who's Online command
   async fn handle_whos_online(&mut self) {
       let nodes = self.state.node_manager.get_active_nodes_full().await;
       let output = crate::services::who::render_whos_online(&nodes);
       let _ = self.tx.send(output).await;
       // Set sentinel service to wait for keypress then return to menu
       self.current_service = Some("__whos_online__".to_string());

       if let Some(node_id) = self.node_id {
           self.state.node_manager.update_activity(node_id, "Who's Online").await;
       }
   }

   /// Handle Last Callers command
   async fn handle_last_callers(&mut self) {
       let limit = self.state.config.time_limits.last_callers_count;
       let entries = crate::db::session_history::get_last_callers(
           &self.state.db_pool, limit
       ).await.unwrap_or_default();
       let output = crate::services::last_callers::render_last_callers(&entries);
       let _ = self.tx.send(output).await;
       // Set sentinel service to wait for keypress then return to menu
       self.current_service = Some("__last_callers__".to_string());

       if let Some(node_id) = self.node_id {
           self.state.node_manager.update_activity(node_id, "Last Callers").await;
       }
   }

   /// Handle User Lookup start -- show prompt
   async fn handle_user_lookup_start(&mut self) {
       let prompt = crate::services::user_profile::render_lookup_prompt();
       let _ = self.tx.send(prompt).await;
       self.current_service = Some("__user_lookup__".to_string());
       self.lookup_input = Some(String::new());

       if let Some(node_id) = self.node_id {
           self.state.node_manager.update_activity(node_id, "User Lookup").await;
       }
   }
   ```

3. Handle input for the sentinel services.

   In handle_authenticated_input, in the block that checks current_service BEFORE the menu processing, add handling for the new sentinels:

   ```rust
   // Who's Online and Last Callers: any keypress returns to menu
   if service_name == "__whos_online__" || service_name == "__last_callers__" {
       let trimmed = input.trim();
       if !trimmed.is_empty() && !trimmed.starts_with('\x1b') {
           self.current_service = None;
           if let Some(ms) = &mut self.menu_session {
               ms.reset_to_main();
           }
           self.show_menu().await;
       }
       return;
   }

   // User Lookup: character-by-character input for handle
   if service_name == "__user_lookup__" {
       self.handle_user_lookup_input(input).await;
       return;
   }
   ```

4. Implement user lookup input handler:
   ```rust
   async fn handle_user_lookup_input(&mut self, input: &str) {
       let tx = self.tx.clone();

       for ch in input.chars() {
           if ch == '\r' || ch == '\n' {
               let handle_input = self.lookup_input.take().unwrap_or_default();
               let _ = tx.send("\r\n".to_string()).await;

               if handle_input.eq_ignore_ascii_case("q") || handle_input.is_empty() {
                   // Cancel lookup
                   self.current_service = None;
                   if let Some(ms) = &mut self.menu_session {
                       ms.reset_to_main();
                   }
                   self.show_menu().await;
                   return;
               }

               // Look up user
               match crate::db::user::find_user_by_handle(&self.state.db_pool, &handle_input).await {
                   Ok(Some(user)) => {
                       // Show profile card (read-only)
                       let card = crate::services::profile::render_profile_card(&user, false);
                       let _ = tx.send(card).await;
                       let footer = crate::services::user_profile::render_profile_footer();
                       let _ = tx.send(footer).await;
                       // Switch to "viewing profile" state -- next keypress returns to lookup prompt
                       self.current_service = Some("__user_lookup_view__".to_string());
                   }
                   _ => {
                       let err = crate::services::user_profile::render_user_not_found(&handle_input);
                       let _ = tx.send(err).await;
                       // Stay in lookup mode, reinitialize input
                       self.lookup_input = Some(String::new());
                       // Next keypress shows prompt again
                       self.current_service = Some("__user_lookup_retry__".to_string());
                   }
               }
               return;
           } else if ch == '\x7f' || ch == '\x08' {
               // Backspace
               if let Some(buf) = &mut self.lookup_input {
                   if buf.pop().is_some() {
                       let _ = tx.send("\x08 \x08".to_string()).await;
                   }
               }
           } else if !ch.is_control() {
               if let Some(buf) = &mut self.lookup_input {
                   buf.push(ch);
               }
               let _ = tx.send(ch.to_string()).await;
           }
       }
   }
   ```

   Add handling for __user_lookup_view__ and __user_lookup_retry__ sentinels:
   ```rust
   if service_name == "__user_lookup_view__" || service_name == "__user_lookup_retry__" {
       let trimmed = input.trim();
       if !trimmed.is_empty() && !trimmed.starts_with('\x1b') {
           // Return to lookup prompt
           self.handle_user_lookup_start().await;
       }
       return;
   }
   ```

5. Handle timeout in websocket/mod.rs:

   The timer sends a { "type": "timeout" } JSON message through the tx channel to the client. But we also need the SERVER to know when time expires to trigger the timeout sequence.

   Approach: The session needs to check if the timer has expired. Since the timer task runs independently, we need a way for it to signal the session. Options:
   a) Check `session_timer.is_running()` periodically -- not great
   b) Have the timer signal via a separate channel
   c) Use CancellationToken in reverse -- timer cancels a "timeout token" that session watches

   Best approach: Add a timeout_token (CancellationToken) to SessionTimer that gets cancelled when time expires. The session's input handling loop checks this.

   Actually, simplest approach: The timer already sends { "type": "timeout" } through the tx channel. But that goes to the CLIENT. For the server, modify the timer to also signal via a separate oneshot channel or CancellationToken.

   Alternative (simpler): Add a `timeout_signal: Arc<AtomicBool>` to SessionTimer. Timer sets it to true when expired. Session checks it on each input.

   Even simpler: Make the timer set a CancellationToken (timeout_token) when it expires. Session.handle_input checks at the start:
   ```rust
   // Check for timeout
   if let Some(timer) = &self.session_timer {
       if !timer.is_running() {
           // Timer completed -- check if expired
           // Take the timer to get the result
       }
   }
   ```

   Actually, the cleanest pattern: Add a `pub fn expired(&self) -> bool` method to SessionTimer that checks if the task finished AND returned Expired. Use a shared Arc<AtomicBool>.

   Modify timer.rs: Add `expired: Arc<std::sync::atomic::AtomicBool>` field. Set to true in run_timer when time expires (before returning TimerResult::Expired). Add `pub fn is_expired(&self) -> bool` method.

   Then in session.rs, at the start of handle_input (or handle_authenticated_input):
   ```rust
   // Check for timeout
   if let Some(timer) = &self.session_timer {
       if timer.is_expired() {
           self.handle_timeout().await;
           return;
       }
   }
   ```

   Implement handle_timeout:
   ```rust
   async fn handle_timeout(&mut self) {
       // Take timer to prevent double handling
       let timer = self.session_timer.take();
       if let Some(t) = timer {
           t.cancel(); // Ensure task is cleaned up
       }

       // Send logout JSON to frontend
       let logout_msg = serde_json::json!({ "type": "logout" });
       let _ = self.tx.send(serde_json::to_string(&logout_msg).unwrap()).await;

       if let AuthState::Authenticated { user_id, handle, token, login_time, .. } = &self.auth_state {
           let session_secs = login_time.elapsed().as_secs();
           let session_minutes = (session_secs / 60) as i64;

           // Update daily time used
           let _ = crate::db::user::update_daily_time_used(
               &self.state.db_pool, *user_id, session_minutes
           ).await;

           // Update total time
           let _ = crate::db::user::update_user_time(
               &self.state.db_pool, *user_id, session_minutes
           ).await;

           // Update session history
           if let Some(history_id) = self.session_history_id {
               let _ = crate::db::session_history::update_session_history_logout(
                   &self.state.db_pool, history_id, session_minutes as i32
               ).await;
           }

           // Fetch stats for goodbye
           let (total_calls, total_time) = match crate::db::user::find_user_by_id(&self.state.db_pool, *user_id).await {
               Ok(Some(u)) => (u.total_logins as i64, u.total_time_minutes as i64),
               _ => (0, session_minutes),
           };

           // Render timeout goodbye
           let goodbye = crate::services::goodbye::render_timeout_goodbye(
               handle, session_minutes, total_calls, total_time
           );
           let _ = self.tx.send(goodbye).await;

           // Delete session token
           let _ = crate::auth::session::delete_session(&self.state.db_pool, token).await;

           println!("User {} timed out ({}m session)", handle, session_minutes);
       }

       // Let user read the goodbye screen
       tokio::time::sleep(Duration::from_secs(3)).await;
       self.disconnecting = true;
   }
   ```

6. Handle time bank withdrawal at 1-minute warning:

   The timer sends { "type": "timer_warning", "minutes": 1 } to the client. But the server also needs to handle this for the withdrawal prompt.

   Approach: When the timer reaches 1 minute remaining, it could also set a flag or send a signal. But since the withdrawal prompt needs user interaction, and the timer is server-side...

   Simplest approach: The timer sends the warning. The session doesn't need to intercept it server-side because the frontend already changes the status bar to red. For the withdrawal prompt, add a `withdrawal_prompted: bool` flag. When the timer's remaining hits the 1-minute mark, the session checks on the next input if banked time is available and offers withdrawal.

   Actually, since we can't easily intercept the 1-minute mark in the session (the timer runs independently), use a simpler approach: check at each input whether remaining time is <= 1 minute AND withdrawal hasn't been prompted yet. But we'd need to track remaining time in the session.

   Even simpler: Add a method to SessionTimer that returns the approximate remaining minutes. Or: when the timer switches to per-second mode, set a flag that the session can read.

   Most practical approach for v1: Skip the interactive withdrawal prompt. Instead, auto-withdraw banked time when daily time runs out. The user sees "Using X minutes of banked time" at login (already implemented above). If they run out mid-session, the timer expires and they get timed out. They can log back in and the system will auto-withdraw banked time.

   This matches the CONTEXT decision: "Prompt at 1-minute warning. If user responds, banked time applied. If not, time expires."

   For the prompt: Add a `withdrawal_offered: bool` to Session. The timer can signal "low time" via another shared flag. On each input, if low_time flag is set and !withdrawal_offered, show the prompt. Set withdrawal_offered = true.

   Implement:
   - Add `low_time: Arc<AtomicBool>` to SessionTimer (set when remaining <= 1 minute)
   - Add `withdrawal_offered: bool` to Session (default false)
   - In handle_authenticated_input, before processing input:
     ```rust
     if !self.withdrawal_offered {
         if let Some(timer) = &self.session_timer {
             if timer.is_low_time() {
                 self.withdrawal_offered = true;
                 // Check if banked time available
                 if let AuthState::Authenticated { user_id, .. } = &self.auth_state {
                     let banked = match crate::db::user::get_user_time_info(&self.state.db_pool, *user_id).await {
                         Ok((_, b, _)) => b,
                         Err(_) => 0,
                     };
                     if banked > 0 {
                         // Offer withdrawal -- non-blocking message
                         let mut w = AnsiWriter::new();
                         w.writeln("");
                         w.set_fg(Color::Yellow);
                         w.bold();
                         w.writeln(&format!("  WARNING: Less than 1 minute remaining!"));
                         w.writeln(&format!("  You have {} minutes in your time bank.", banked));
                         w.writeln("  Press [B] to use banked time, or any other key to continue.");
                         w.reset_color();
                         let _ = self.tx.send(w.flush()).await;
                         self.current_service = Some("__time_bank_prompt__".to_string());
                         return; // Wait for response
                     }
                 }
             }
         }
     }
     ```
   - Handle __time_bank_prompt__ sentinel:
     ```rust
     if service_name == "__time_bank_prompt__" {
         let trimmed = input.trim();
         if trimmed.eq_ignore_ascii_case("b") {
             // Withdraw banked time
             if let AuthState::Authenticated { user_id, .. } = &self.auth_state {
                 let withdrawn = crate::db::user::withdraw_banked_time(
                     &self.state.db_pool, *user_id, 30 // Withdraw 30 minutes
                 ).await.unwrap_or(0);
                 if withdrawn > 0 {
                     let mut w = AnsiWriter::new();
                     w.set_fg(Color::LightGreen);
                     w.writeln(&format!("  {} minutes of banked time applied!", withdrawn));
                     w.reset_color();
                     let _ = self.tx.send(w.flush()).await;
                     // Restart timer with new remaining time
                     // Cancel old timer, start new one
                     if let Some(old_timer) = self.session_timer.take() {
                         old_timer.cancel();
                     }
                     let (active, _) = self.state.node_manager.get_status().await;
                     let handle = match &self.auth_state {
                         AuthState::Authenticated { handle, .. } => handle.clone(),
                         _ => "Unknown".to_string(),
                     };
                     let new_timer = crate::connection::timer::SessionTimer::spawn(
                         self.tx.clone(), withdrawn, handle, active,
                     );
                     self.session_timer = Some(new_timer);
                     self.withdrawal_offered = false; // Allow re-prompt if they run low again
                 }
             }
         }
         // Return to menu regardless
         self.current_service = None;
         if let Some(ms) = &mut self.menu_session {
             ms.reset_to_main();
         }
         self.show_menu().await;
         return;
     }
     ```

7. Update timer.rs to add `expired` and `low_time` flags:
   Add `Arc<AtomicBool>` fields for `expired` and `low_time`. Set them in run_timer at appropriate points. Add `is_expired()` and `is_low_time()` public methods.

   NOTE: This requires modifying timer.rs (from Plan 02). Since this is Wave 3 and depends on Plan 02, that's fine -- we're extending it.
  </action>
  <verify>
    `cargo check` passes with all integration code.
    `cargo test` passes (existing tests still work).
  </verify>
  <done>
    Timer starts on all authentication paths (login, resume, registration).
    Daily time reset checked on login with auto-banking of unused time.
    Timer cancelled on quit and disconnect.
    Timeout triggers goodbye screen with time-expired messaging.
    Time bank withdrawal prompted at 1-minute warning.
    Session history recorded on login, updated on logout.
    Who's Online, Last Callers, User Lookup commands routed from menu.
    User Lookup has character-by-character handle input with profile display.
    NodeManager activity updated during navigation.
  </done>
</task>

</tasks>

<verification>
- `cargo check` passes (full project compiles)
- `cargo test` passes (all existing tests)
- Full login -> timer starts -> status bar visible -> navigate to Who's Online -> see users -> return -> quit -> timer cancels -> goodbye
- Timer warning at 5 and 1 minute changes status bar color
- Timeout at 0 shows time expired goodbye
- Session history shows in Last Callers
- User Lookup finds and displays profiles
</verification>

<success_criteria>
- Timer lifecycle fully integrated into session (start, cancel, timeout)
- Daily reset + time banking triggered on login
- All 3 Phase 4 commands (W, L, U) work from main menu
- Timeout produces distinct goodbye screen
- Time bank withdrawal works at 1-minute warning
- Session history tracks all logins/logouts
- No double cleanup on quit vs timeout race
</success_criteria>

<output>
After completion, create `.planning/phases/04-time-limits-user-lists/04-06-SUMMARY.md`
</output>
