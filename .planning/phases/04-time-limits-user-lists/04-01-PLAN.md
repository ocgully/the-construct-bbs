---
phase: 04-time-limits-user-lists
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/schema.sql
  - backend/src/config.rs
  - backend/src/db/user.rs
  - backend/src/db/session_history.rs
  - backend/src/db/mod.rs
  - backend/src/connection/node_manager.rs
autonomous: true

must_haves:
  truths:
    - "Time limits configurable per user level in config.toml"
    - "Session history table exists for tracking last callers"
    - "User table has time banking columns (daily_time_used, banked_time)"
    - "NodeManager tracks current activity and last input time for idle detection"
  artifacts:
    - path: "backend/src/config.rs"
      provides: "TimeLimitsConfig with per-level time limits and bank caps"
      contains: "TimeLimitsConfig"
    - path: "backend/src/db/schema.sql"
      provides: "session_history table, time banking columns on users"
      contains: "session_history"
    - path: "backend/src/db/session_history.rs"
      provides: "Session history CRUD (insert, query last callers)"
      contains: "insert_session_history"
    - path: "backend/src/db/user.rs"
      provides: "Time banking queries (get/update daily_time_used, banked_time)"
      contains: "update_daily_time"
    - path: "backend/src/connection/node_manager.rs"
      provides: "NodeInfo with current_activity and last_input fields"
      contains: "current_activity"
  key_links:
    - from: "backend/src/config.rs"
      to: "config.toml"
      via: "serde deserialization"
      pattern: "TimeLimitsConfig"
    - from: "backend/src/db/session_history.rs"
      to: "backend/src/db/schema.sql"
      via: "sqlx queries against session_history table"
      pattern: "session_history"
---

<objective>
Create the database schema extensions, configuration types, and data layer functions that all other Phase 4 plans depend on.

Purpose: Every Phase 4 feature (timer, status bar, who's online, last callers, time banking) needs shared data structures and DB tables. This plan establishes the foundation.
Output: TimeLimitsConfig in config.rs, session_history table + queries, time banking columns + queries on users, NodeManager with activity/idle tracking.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-time-limits-user-lists/04-CONTEXT.md
@.planning/phases/04-time-limits-user-lists/04-RESEARCH.md
@backend/src/config.rs
@backend/src/db/schema.sql
@backend/src/db/user.rs
@backend/src/db/pool.rs
@backend/src/db/mod.rs
@backend/src/connection/node_manager.rs
@config.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Time Limits Config and Database Schema Extensions</name>
  <files>
    backend/src/config.rs
    backend/src/db/schema.sql
    config.toml
  </files>
  <action>
1. Add TimeLimitsConfig to config.rs:
   ```rust
   #[derive(Debug, Deserialize, Serialize, Clone)]
   pub struct TimeLevelConfig {
       pub daily_minutes: i64,        // 0 = unlimited (sysop)
       pub time_bank_cap: i64,        // max minutes that can be banked
   }

   #[derive(Debug, Deserialize, Serialize, Clone)]
   pub struct TimeLimitsConfig {
       #[serde(default = "default_guest_time")]
       pub guest: TimeLevelConfig,
       #[serde(default = "default_user_time")]
       pub user: TimeLevelConfig,
       #[serde(default = "default_sysop_time")]
       pub sysop: TimeLevelConfig,
       #[serde(default = "default_last_callers_count")]
       pub last_callers_count: i32,
   }
   ```
   - Default values: Guest=30min/0bank, User=60min/120bank, Sysop=0(unlimited)/0bank
   - last_callers_count defaults to 15
   - Add `#[serde(default)]` field `pub time_limits: TimeLimitsConfig` to Config struct
   - Implement Default for TimeLimitsConfig and TimeLevelConfig
   - Add helper method `pub fn get_time_config(&self, user_level: &str) -> &TimeLevelConfig` that matches "Sysop"|"Guest"|_ (default User)

2. Add session_history table to schema.sql:
   ```sql
   CREATE TABLE IF NOT EXISTS session_history (
       id INTEGER PRIMARY KEY,
       user_id INTEGER NOT NULL,
       handle TEXT NOT NULL,
       login_time TEXT NOT NULL DEFAULT (datetime('now', '-5 hours')),
       logout_time TEXT,
       duration_minutes INTEGER NOT NULL DEFAULT 0,
       FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
   );
   CREATE INDEX IF NOT EXISTS idx_session_history_login ON session_history(login_time);
   ```

3. Add time banking columns to users table in schema.sql:
   ```sql
   -- Add after existing users table (use ALTER TABLE since IF NOT EXISTS tables):
   -- These are safe to re-run because SQLite silently ignores duplicate column adds
   ```
   IMPORTANT: Since schema.sql uses CREATE TABLE IF NOT EXISTS and runs every startup, add the new columns directly to the CREATE TABLE statement (daily_time_used INTEGER NOT NULL DEFAULT 0, banked_time INTEGER NOT NULL DEFAULT 0, last_daily_reset TEXT). This is safe because the IF NOT EXISTS means existing DBs keep their table. For existing databases, also add ALTER TABLE statements wrapped in a way that won't fail if columns already exist. The simplest approach: add the columns to the CREATE TABLE, and for migration of existing DBs, the executor should handle it (the pool.rs already splits by semicolon).

   Actually, the cleanest approach for SQLite: just add the columns to the existing CREATE TABLE IF NOT EXISTS statement. If the table already exists, SQLite skips the CREATE entirely. For existing databases, we need separate ALTER TABLE statements. Add them at the bottom of schema.sql with a comment:
   ```sql
   -- Migration: add time banking columns (Phase 4)
   -- ALTER TABLE users ADD COLUMN daily_time_used INTEGER NOT NULL DEFAULT 0;
   -- ALTER TABLE users ADD COLUMN banked_time INTEGER NOT NULL DEFAULT 0;
   -- ALTER TABLE users ADD COLUMN last_daily_reset TEXT;
   ```
   But ALTER TABLE ADD COLUMN fails if column exists. So: modify the User struct to handle both scenarios. Best approach: add columns to the CREATE TABLE block (for new DBs) AND add a migration helper function in pool.rs that tries ALTER TABLE and ignores "duplicate column" errors. Actually, keep it simple -- just add to the CREATE TABLE statement AND add ALTER TABLE statements. In pool.rs, the init_pool already runs each statement and can be modified to ignore "duplicate column" errors. But don't modify pool.rs yet -- just add the columns to the CREATE TABLE for new databases and note for Plan 06 integration.

   Simplest: Add daily_time_used, banked_time, last_daily_reset to the CREATE TABLE IF NOT EXISTS users statement. For existing databases, the dev can drop and recreate (dev stage). This matches the existing pattern.

4. Add [time_limits] section to config.toml:
   ```toml
   [time_limits]
   last_callers_count = 15

   [time_limits.guest]
   daily_minutes = 30
   time_bank_cap = 0

   [time_limits.user]
   daily_minutes = 60
   time_bank_cap = 120

   [time_limits.sysop]
   daily_minutes = 0
   time_bank_cap = 0
   ```
  </action>
  <verify>
    `cargo check` in backend directory passes (config deserializes correctly).
    Config.toml parses with new [time_limits] section.
  </verify>
  <done>
    TimeLimitsConfig exists in config.rs with per-level daily_minutes and time_bank_cap.
    Schema.sql contains session_history table and time banking columns on users.
    Config.toml has [time_limits] section with Guest/User/Sysop defaults.
  </done>
</task>

<task type="auto">
  <name>Task 2: Session History DB Module, Time Banking Queries, and NodeManager Extensions</name>
  <files>
    backend/src/db/session_history.rs
    backend/src/db/mod.rs
    backend/src/db/user.rs
    backend/src/connection/node_manager.rs
  </files>
  <action>
1. Create backend/src/db/session_history.rs:
   ```rust
   use sqlx::sqlite::SqlitePool;
   use sqlx::FromRow;

   #[derive(Debug, Clone, FromRow)]
   pub struct SessionHistoryEntry {
       pub id: i64,
       pub user_id: i64,
       pub handle: String,
       pub login_time: String,
       pub logout_time: Option<String>,
       pub duration_minutes: i32,
   }

   pub async fn insert_session_history(
       pool: &SqlitePool,
       user_id: i64,
       handle: &str,
   ) -> Result<i64, sqlx::Error> {
       // Insert with login_time auto-set by DEFAULT
       let result = sqlx::query(
           "INSERT INTO session_history (user_id, handle) VALUES (?, ?)"
       )
       .bind(user_id)
       .bind(handle)
       .execute(pool)
       .await?;
       Ok(result.last_insert_rowid())
   }

   pub async fn update_session_history_logout(
       pool: &SqlitePool,
       session_history_id: i64,
       duration_minutes: i32,
   ) -> Result<(), sqlx::Error> {
       sqlx::query(
           "UPDATE session_history SET logout_time = datetime('now', '-5 hours'), duration_minutes = ? WHERE id = ?"
       )
       .bind(duration_minutes)
       .bind(session_history_id)
       .execute(pool)
       .await?;
       Ok(())
   }

   pub async fn get_last_callers(
       pool: &SqlitePool,
       limit: i32,
   ) -> Result<Vec<SessionHistoryEntry>, sqlx::Error> {
       sqlx::query_as::<_, SessionHistoryEntry>(
           "SELECT id, user_id, handle, login_time, logout_time, duration_minutes
            FROM session_history
            ORDER BY login_time DESC
            LIMIT ?"
       )
       .bind(limit)
       .fetch_all(pool)
       .await
   }
   ```

2. Add `pub mod session_history;` to backend/src/db/mod.rs.

3. Add time banking query functions to backend/src/db/user.rs:
   ```rust
   /// Check if daily time needs resetting (day boundary crossed since last reset).
   pub async fn check_daily_reset(pool: &SqlitePool, user_id: i64) -> Result<bool, sqlx::Error> {
       let row: (i32,) = sqlx::query_as(
           "SELECT CASE
               WHEN last_daily_reset IS NULL THEN 1
               WHEN date(last_daily_reset) < date('now', '-5 hours') THEN 1
               ELSE 0
           END FROM users WHERE id = ?"
       )
       .bind(user_id)
       .fetch_one(pool)
       .await?;
       Ok(row.0 == 1)
   }

   /// Reset daily time usage and bank unused time.
   /// Returns the amount of time that was banked.
   pub async fn reset_daily_time(
       pool: &SqlitePool,
       user_id: i64,
       daily_limit: i64,
       bank_cap: i64,
   ) -> Result<i64, sqlx::Error> {
       // First, get current daily_time_used and banked_time
       let row: (i32, i32) = sqlx::query_as(
           "SELECT daily_time_used, banked_time FROM users WHERE id = ?"
       )
       .bind(user_id)
       .fetch_one(pool)
       .await?;

       let used = row.0 as i64;
       let current_bank = row.1 as i64;
       let unused = (daily_limit - used).max(0);
       let new_bank = (current_bank + unused).min(bank_cap);
       let banked_amount = new_bank - current_bank;

       sqlx::query(
           "UPDATE users SET daily_time_used = 0, banked_time = ?, last_daily_reset = datetime('now', '-5 hours') WHERE id = ?"
       )
       .bind(new_bank)
       .bind(user_id)
       .execute(pool)
       .await?;

       Ok(banked_amount)
   }

   /// Update daily time used (increment by minutes spent).
   pub async fn update_daily_time_used(
       pool: &SqlitePool,
       user_id: i64,
       minutes: i64,
   ) -> Result<(), sqlx::Error> {
       sqlx::query("UPDATE users SET daily_time_used = daily_time_used + ? WHERE id = ?")
           .bind(minutes)
           .bind(user_id)
           .execute(pool)
           .await?;
       Ok(())
   }

   /// Get user's remaining daily time in minutes.
   /// Returns (remaining_minutes, banked_minutes, daily_limit).
   pub async fn get_user_time_info(
       pool: &SqlitePool,
       user_id: i64,
   ) -> Result<(i64, i64, i64), sqlx::Error> {
       let row: (i32, i32) = sqlx::query_as(
           "SELECT daily_time_used, banked_time FROM users WHERE id = ?"
       )
       .bind(user_id)
       .fetch_one(pool)
       .await?;
       Ok((row.0 as i64, row.1 as i64, 0)) // daily_limit filled by caller from config
   }

   /// Withdraw banked time (add to daily allowance effectively by reducing daily_time_used).
   pub async fn withdraw_banked_time(
       pool: &SqlitePool,
       user_id: i64,
       minutes: i64,
   ) -> Result<i64, sqlx::Error> {
       // Get current banked time
       let row: (i32,) = sqlx::query_as(
           "SELECT banked_time FROM users WHERE id = ?"
       )
       .bind(user_id)
       .fetch_one(pool)
       .await?;

       let available = row.0 as i64;
       let withdraw = minutes.min(available);

       sqlx::query(
           "UPDATE users SET banked_time = banked_time - ?, daily_time_used = CASE WHEN daily_time_used >= ? THEN daily_time_used - ? ELSE 0 END WHERE id = ?"
       )
       .bind(withdraw)
       .bind(withdraw)
       .bind(withdraw)
       .bind(user_id)
       .execute(pool)
       .await?;

       Ok(withdraw)
   }
   ```

   Also update the User struct to include the new columns:
   ```rust
   pub daily_time_used: i32,
   pub banked_time: i32,
   pub last_daily_reset: Option<String>,
   ```

4. Extend NodeManager in connection/node_manager.rs:
   - Add `current_activity: String` and `last_input: chrono::DateTime<chrono::Utc>` to NodeInfo
   - Initialize current_activity to "Connecting" in assign_node, last_input to Utc::now()
   - Add `pub async fn update_activity(&self, node_id: usize, activity: &str)` method
   - Add `pub async fn update_last_input(&self, node_id: usize)` method
   - Add `pub async fn get_active_nodes_full(&self) -> Vec<(usize, NodeInfo)>` returning full NodeInfo (for Who's Online)
   - Fix existing tests to include new NodeInfo fields
  </action>
  <verify>
    `cargo check` passes.
    `cargo test` passes (including updated NodeManager tests).
  </verify>
  <done>
    session_history.rs exists with insert, update_logout, get_last_callers functions.
    User struct has daily_time_used, banked_time, last_daily_reset fields.
    Time banking queries exist: check_daily_reset, reset_daily_time, update_daily_time_used, withdraw_banked_time.
    NodeManager has current_activity, last_input on NodeInfo with update methods.
  </done>
</task>

</tasks>

<verification>
- `cargo check` compiles cleanly with all new types and functions
- `cargo test` passes including updated NodeManager tests
- Config.toml loads with [time_limits] section
- Schema.sql has session_history table and time banking columns
</verification>

<success_criteria>
- TimeLimitsConfig exists with per-level configuration
- Session history DB module created with CRUD functions
- Time banking queries ready for timer and session integration
- NodeManager tracks activity and idle time per node
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-time-limits-user-lists/04-01-SUMMARY.md`
</output>
