---
phase: 08-first-door-game-drug-wars
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/grand_theft_meth/db.rs
  - backend/src/services/grand_theft_meth/mod.rs
autonomous: true

must_haves:
  truths:
    - "Game has its own separate database file (grand_theft_meth.db)"
    - "Game saves can be stored and retrieved per user"
    - "Completed games are recorded for leaderboard"
    - "Leaderboard shows top 10 players ranked by score"
  artifacts:
    - path: "backend/src/services/grand_theft_meth/db.rs"
      provides: "Self-contained game database with save/load and leaderboard"
      exports: ["GtmDb", "LeaderboardEntry"]
  key_links:
    - from: "backend/src/services/grand_theft_meth/db.rs"
      to: "grand_theft_meth.db file"
      via: "dedicated SqlitePool"
      pattern: "SqlitePool.*grand_theft_meth"
---

<objective>
Create self-contained database for Grand Theft Meth door game.

Purpose: Each door game is a pluggable module with its own database - no coupling to BBS core database. This establishes the pattern for all future door games.
Output: GtmDb struct managing its own SQLite pool with save/load and leaderboard operations.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-first-door-game-drug-wars/08-CONTEXT.md
@.planning/phases/08-first-door-game-drug-wars/08-RESEARCH.md
@backend/src/db/pool.rs (for SqlitePool pattern reference only)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create game module directory and database module</name>
  <files>backend/src/services/grand_theft_meth/mod.rs, backend/src/services/grand_theft_meth/db.rs</files>
  <action>
Create backend/src/services/grand_theft_meth/ directory.

Create backend/src/services/grand_theft_meth/mod.rs with:
```rust
pub mod db;

pub use db::GtmDb;
```

Create backend/src/services/grand_theft_meth/db.rs with:

1. GtmDb struct that owns its own SqlitePool:
   ```rust
   use sqlx::sqlite::{SqlitePool, SqlitePoolOptions};
   use std::path::Path;

   pub struct GtmDb {
       pool: SqlitePool,
   }
   ```

2. Constructor that creates/opens database file:
   ```rust
   impl GtmDb {
       pub async fn new(db_path: &Path) -> Result<Self, sqlx::Error> {
           // Create parent directory if needed
           if let Some(parent) = db_path.parent() {
               std::fs::create_dir_all(parent).ok();
           }

           let db_url = format!("sqlite:{}?mode=rwc", db_path.display());
           let pool = SqlitePoolOptions::new()
               .max_connections(5)
               .connect(&db_url)
               .await?;

           // Enable WAL mode for concurrency
           sqlx::query("PRAGMA journal_mode=WAL")
               .execute(&pool)
               .await?;

           let db = Self { pool };
           db.init_schema().await?;
           Ok(db)
       }
   }
   ```

3. Schema initialization (called from constructor):
   ```rust
   async fn init_schema(&self) -> Result<(), sqlx::Error> {
       sqlx::query(r#"
           CREATE TABLE IF NOT EXISTS saves (
               user_id INTEGER PRIMARY KEY,
               handle TEXT NOT NULL,
               state_json TEXT NOT NULL,
               last_saved TEXT NOT NULL
           )
       "#).execute(&self.pool).await?;

       sqlx::query(r#"
           CREATE TABLE IF NOT EXISTS completions (
               id INTEGER PRIMARY KEY AUTOINCREMENT,
               user_id INTEGER NOT NULL,
               handle TEXT NOT NULL,
               final_score INTEGER NOT NULL,
               days_played INTEGER NOT NULL,
               story_completed INTEGER NOT NULL,
               completed_at TEXT NOT NULL
           )
       "#).execute(&self.pool).await?;

       sqlx::query(r#"
           CREATE INDEX IF NOT EXISTS idx_completions_score
           ON completions(final_score DESC)
       "#).execute(&self.pool).await?;

       Ok(())
   }
   ```

4. Save/load operations:
   ```rust
   pub async fn save_game(&self, user_id: i64, handle: &str, state_json: &str) -> Result<(), sqlx::Error> {
       sqlx::query(
           "INSERT OR REPLACE INTO saves (user_id, handle, state_json, last_saved)
            VALUES (?, ?, ?, datetime('now', '-5 hours'))"
       )
       .bind(user_id)
       .bind(handle)
       .bind(state_json)
       .execute(&self.pool)
       .await?;
       Ok(())
   }

   pub async fn load_game(&self, user_id: i64) -> Result<Option<String>, sqlx::Error> {
       let row: Option<(String,)> = sqlx::query_as(
           "SELECT state_json FROM saves WHERE user_id = ?"
       )
       .bind(user_id)
       .fetch_optional(&self.pool)
       .await?;
       Ok(row.map(|r| r.0))
   }

   pub async fn delete_save(&self, user_id: i64) -> Result<(), sqlx::Error> {
       sqlx::query("DELETE FROM saves WHERE user_id = ?")
           .bind(user_id)
           .execute(&self.pool)
           .await?;
       Ok(())
   }

   pub async fn has_save(&self, user_id: i64) -> Result<bool, sqlx::Error> {
       let row: Option<(i64,)> = sqlx::query_as(
           "SELECT 1 FROM saves WHERE user_id = ?"
       )
       .bind(user_id)
       .fetch_optional(&self.pool)
       .await?;
       Ok(row.is_some())
   }
   ```

5. Completion recording:
   ```rust
   pub async fn record_completion(
       &self,
       user_id: i64,
       handle: &str,
       final_score: i64,
       days_played: i64,
       story_completed: bool,
   ) -> Result<i64, sqlx::Error> {
       let result = sqlx::query(
           "INSERT INTO completions (user_id, handle, final_score, days_played, story_completed, completed_at)
            VALUES (?, ?, ?, ?, ?, datetime('now', '-5 hours'))"
       )
       .bind(user_id)
       .bind(handle)
       .bind(final_score)
       .bind(days_played)
       .bind(story_completed as i64)
       .execute(&self.pool)
       .await?;
       Ok(result.last_insert_rowid())
   }
   ```

6. Leaderboard struct and query:
   ```rust
   #[derive(Debug, Clone)]
   pub struct LeaderboardEntry {
       pub rank: i64,
       pub handle: String,
       pub final_score: i64,
       pub days_played: i64,
       pub completed_at: String,
       pub story_completed: bool,
   }

   pub async fn get_leaderboard(&self, limit: i64) -> Result<Vec<LeaderboardEntry>, sqlx::Error> {
       let rows: Vec<(i64, String, i64, i64, String, i64)> = sqlx::query_as(
           r#"
           SELECT
               RANK() OVER (ORDER BY final_score DESC) as rank,
               handle,
               final_score,
               days_played,
               completed_at,
               story_completed
           FROM completions
           ORDER BY final_score DESC
           LIMIT ?
           "#
       )
       .bind(limit)
       .fetch_all(&self.pool)
       .await?;

       Ok(rows.into_iter().map(|(rank, handle, score, days, completed, story)| {
           LeaderboardEntry {
               rank,
               handle,
               final_score: score,
               days_played: days,
               completed_at: completed,
               story_completed: story != 0,
           }
       }).collect())
   }
   ```

Database file location: Use data/grand_theft_meth.db relative to working directory (alongside bbs.db).
  </action>
  <verify>
Run `cargo check` in backend directory - no compilation errors.
  </verify>
  <done>
grand_theft_meth/db.rs exists with GtmDb struct owning its own SqlitePool.
All CRUD operations implemented: save_game, load_game, delete_save, has_save.
Leaderboard query with RANK() window function.
Module exported from grand_theft_meth/mod.rs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Export game module from services</name>
  <files>backend/src/services/mod.rs</files>
  <action>
Update backend/src/services/mod.rs to add:
```rust
pub mod grand_theft_meth;
```

The game module is now accessible as services::grand_theft_meth::GtmDb.
  </action>
  <verify>
Run `cargo check` - module exports correctly.
  </verify>
  <done>
grand_theft_meth module exported from services/mod.rs.
  </done>
</task>

</tasks>

<verification>
Run `cargo check` - all pass.
grand_theft_meth.db will be created on first game launch (not at BBS startup).
</verification>

<success_criteria>
- Game has dedicated database file separate from BBS (grand_theft_meth.db)
- GtmDb struct encapsulates all database operations
- Schema created on first connection (idempotent with IF NOT EXISTS)
- No coupling to BBS db/pool.rs - fully self-contained
</success_criteria>

<output>
After completion, create `.planning/phases/08-first-door-game-drug-wars/08-01-SUMMARY.md`
</output>
