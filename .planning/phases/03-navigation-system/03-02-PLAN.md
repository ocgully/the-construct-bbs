---
phase: 03-navigation-system
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/src/menu/state.rs
  - backend/src/menu/render.rs
  - backend/src/menu/mod.rs
autonomous: true

must_haves:
  truths:
    - "Menu state tracks whether user is at main menu or inside a submenu"
    - "State transitions handle submenu entry, back-to-main, service launch, and command execution"
    - "Type-ahead buffer captures keystrokes during transitions and replays them at next menu"
    - "Main menu renders with double-line box border, MOTD quote, and numbered/lettered items"
    - "Submenus render with single-line box border, unique header, and [Q] Back option"
    - "Menu items filtered by user level before rendering"
    - "Help text displays available commands when '?' is pressed"
  artifacts:
    - path: "backend/src/menu/state.rs"
      provides: "MenuState enum, MenuAction enum, TypeAheadBuffer, MenuSession"
      exports: ["MenuState", "MenuAction", "MenuSession"]
    - path: "backend/src/menu/render.rs"
      provides: "Menu screen rendering functions with AnsiWriter"
      exports: ["render_main_menu", "render_submenu", "render_help"]
    - path: "backend/src/menu/mod.rs"
      provides: "Updated module exports including state and render"
  key_links:
    - from: "backend/src/menu/state.rs"
      to: "backend/src/menu/config.rs"
      via: "MenuConfig for item lookup during state transitions"
      pattern: "MenuConfig"
    - from: "backend/src/menu/render.rs"
      to: "backend/src/menu/config.rs"
      via: "MenuItem for rendering menu items"
      pattern: "MenuItem"
    - from: "backend/src/menu/render.rs"
      to: "backend/src/menu/quotes.rs"
      via: "random_stoic_quote for MOTD area"
      pattern: "random_stoic_quote"
    - from: "backend/src/menu/render.rs"
      to: "backend/src/terminal/ansi.rs"
      via: "AnsiWriter for ANSI output generation"
      pattern: "AnsiWriter"
---

<objective>
Build the menu state machine, type-ahead buffer, and ANSI rendering for all menu screens.

Purpose: Implements the core navigation logic -- state transitions between menus, input buffering for command stacking, and authentic Wildcat-style visual rendering with ANSI art headers.
Output: Complete state machine (MenuSession), type-ahead buffer, and rendering functions for main menu, submenus, and help screen.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-navigation-system/03-CONTEXT.md
@.planning/phases/03-navigation-system/03-RESEARCH.md
@.planning/phases/03-navigation-system/03-01-SUMMARY.md
@backend/src/menu/config.rs
@backend/src/menu/quotes.rs
@backend/src/terminal/ansi.rs
@backend/src/services/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Menu state machine and type-ahead buffer</name>
  <files>
    backend/src/menu/state.rs
    backend/src/menu/mod.rs
  </files>
  <action>
Create `backend/src/menu/state.rs` with:

**MenuState enum:**
```rust
#[derive(Debug, Clone)]
pub enum MenuState {
    MainMenu,
    Submenu { submenu_key: String },
}
```

**MenuAction enum** (returned from input handling):
```rust
#[derive(Debug, Clone, PartialEq)]
pub enum MenuAction {
    Redraw,                          // Redraw current menu (Enter, invalid input)
    EnterSubmenu(String),            // Navigate to submenu by key
    BackToMain,                      // Return to main menu from submenu
    LaunchService(String),           // Launch a service by service_name
    ExecuteCommand(String),          // Execute a command ("quit", "profile")
    ShowHelp,                        // Show help text
    Buffered,                        // Input was buffered (during transition)
    None,                            // No action (ignored input)
}
```

**TypeAheadBuffer:**
```rust
use std::collections::VecDeque;

pub struct TypeAheadBuffer {
    buffer: VecDeque<char>,
    max_size: usize,
}

impl TypeAheadBuffer {
    pub fn new() -> Self {
        Self {
            buffer: VecDeque::with_capacity(16),
            max_size: 16,
        }
    }

    pub fn push(&mut self, ch: char) {
        if self.buffer.len() >= self.max_size {
            self.buffer.pop_front();
        }
        self.buffer.push_back(ch);
    }

    pub fn pop(&mut self) -> Option<char> {
        self.buffer.pop_front()
    }

    pub fn is_empty(&self) -> bool {
        self.buffer.is_empty()
    }

    pub fn clear(&mut self) {
        self.buffer.clear();
    }
}
```

**MenuSession** (owns state + buffer + user context):
```rust
pub struct MenuSession {
    state: MenuState,
    typeahead: TypeAheadBuffer,
    user_level: u8,
}
```

Implement MenuSession with these methods:

- `pub fn new(user_level: u8) -> Self` -- starts at MainMenu

- `pub fn state(&self) -> &MenuState` -- read-only access to current state

- `pub fn process_key(&mut self, key: char, config: &MenuConfig) -> MenuAction`:
  Core input handler. Based on current state:

  **At MainMenu:**
  - '?' -> MenuAction::ShowHelp
  - '\r' or '\n' -> MenuAction::Redraw
  - Match against main menu items (filtered by user_level):
    - Submenu item -> transition state to Submenu, return EnterSubmenu
    - Service item -> return LaunchService
    - Command item -> return ExecuteCommand (handles "quit", "profile")
  - No match -> MenuAction::Redraw (invalid input redraws)

  **At Submenu:**
  - '?' -> MenuAction::ShowHelp
  - '\r' or '\n' -> MenuAction::Redraw
  - 'Q'/'q' -> transition state to MainMenu, return BackToMain
  - Match against submenu items (filtered by user_level):
    - Service item -> return LaunchService
    - Command item -> return ExecuteCommand
  - No match -> MenuAction::Redraw

  All hotkey matching uses `eq_ignore_ascii_case`.

- `pub fn buffer_key(&mut self, ch: char)` -- push to type-ahead buffer

- `pub fn drain_buffer(&mut self, config: &MenuConfig) -> Vec<MenuAction>`:
  Process all buffered keys. Stop processing if a LaunchService or ExecuteCommand action is produced (remaining buffer keys stay for later). This is how command stacking works: "G1" buffers 'G' (enters Games submenu) then '1' (launches first game).

- `pub fn reset_to_main(&mut self)` -- force state back to MainMenu (for service exit)

Update `backend/src/menu/mod.rs` to add:
```rust
pub mod state;
pub use state::{MenuState, MenuAction, MenuSession};
```
  </action>
  <verify>
Add tests in state.rs:
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::menu::config::{MenuConfig, MenuItem};

    // Test: process_key at MainMenu with 'Q' returns ExecuteCommand("quit")
    // Test: process_key at Submenu with 'Q' returns BackToMain
    // Test: TypeAheadBuffer push/pop FIFO ordering
    // Test: TypeAheadBuffer respects max_size
    // Test: drain_buffer stops at LaunchService
    // Test: Enter key returns Redraw
}
```
Run `cargo test` -- all tests pass. Run `cargo build` -- compiles cleanly.
  </verify>
  <done>
MenuSession handles state transitions between MainMenu and Submenu states. TypeAheadBuffer provides FIFO buffering with 16-char capacity. process_key correctly routes hotkeys to items using case-insensitive matching. drain_buffer implements command stacking by processing buffered keys and stopping at service launch.
  </done>
</task>

<task type="auto">
  <name>Task 2: ANSI menu rendering (main menu, submenus, help)</name>
  <files>
    backend/src/menu/render.rs
    backend/src/menu/mod.rs
  </files>
  <action>
Create `backend/src/menu/render.rs` with rendering functions using the existing AnsiWriter and CP437 box-drawing patterns established in Phase 1-2.

**BorderStyle enum:**
```rust
#[derive(Debug, Clone, Copy)]
pub enum BorderStyle {
    Double,  // Main menu -- CP437: C9/CD/BB/C8/BC/BA (double-line)
    Single,  // Submenus -- CP437: DA/C4/BF/C0/D9/B3 (single-line)
}
```

**`pub fn render_main_menu(config: &MenuConfig, user_level: u8, handle: &str, user_level_name: &str, node_id: Option<usize>, max_nodes: usize) -> String`:**

Renders the full main menu screen. Layout (80 cols):

1. Clear screen + begin sync
2. Double-line box header:
   - Top border: `[CD repeat 78]`
   - Title row: "THE CONSTRUCT BBS" centered, bold white on LightCyan border
   - Bottom border
3. Blank line
4. MOTD area: Call `random_stoic_quote()`, render centered in DarkGray/LightGray italic style:
   ```
     "The obstacle is the way." -- Marcus Aurelius
   ```
5. Blank line
6. Single-line divider (Brown, like Phase 1 style: C3 + C4 repeat + B4)
7. Blank line
8. Menu items (filtered by user_level, sorted by order):
   - Submenu items: `[G] Games`, `[M] Mail`, etc. in LightGreen hotkey, White name
   - Command items: `[P] Profile`, `[Q] Quit` in same style
   - Adaptive layout: If items <= 7, single column. If > 7, two columns (left column items 1..n/2, right column items n/2+1..n, each column ~38 chars wide).
   - For single column: `  [H] Name` format with 2-space indent
   - For two columns: left at col 2, right at col 42
9. Blank line
10. User info line: `Logged in as: {handle} [{level}]` in LightGreen, right-aligned `Node {id} of {max}` in Yellow
11. Prompt: `Your choice? ` in LightCyan
12. Show cursor + end sync

**`pub fn render_submenu(submenu_key: &str, submenu_name: &str, items: &[&MenuItem], user_level: u8) -> String`:**

Renders a submenu screen. Layout:

1. Clear screen + begin sync
2. Single-line box header (NOT double):
   - Top border: `[C4 repeat 78]` with DA/BF corners
   - Title row: submenu_name centered, bold white on LightCyan border
   - Bottom border: C0/D9 corners
3. Blank line
4. Menu items (already filtered, sorted by caller):
   - Service items: `[1] Drug Wars`, `[2] LORD`, etc.
   - Always single column in submenus (submenus have fewer items)
5. Blank line
6. Back option: `[Q] Back to Main Menu` in LightGreen/White (always last)
7. Blank line
8. Prompt: `Your choice? ` in LightCyan
9. Show cursor + end sync

**`pub fn render_help(state: &MenuState, config: &MenuConfig, user_level: u8) -> String`:**

Renders a help screen explaining available keys. Uses single-line box border.
Content depends on current state:
- At MainMenu: List all hotkeys with descriptions, explain command stacking (e.g., "Type G1 to go directly to Games > item 1"), explain '?' for help, Enter to redraw.
- At Submenu: List submenu hotkeys, explain Q for back, '?' for help, Enter to redraw.

Footer: `Press any key to return to menu...`

**Important rendering notes:**
- Use CP437 box-drawing bytes via `w.write_cp437(&[0xNN])` for border characters (consistent with Phase 1-2 approach)
- All text uses CRLF via `w.writeln()` (established convention)
- Use begin_sync/end_sync to prevent screen tearing
- Use clear_screen before each menu render
- Colors: LightCyan for borders, White bold for titles, LightGreen for hotkeys, White for item names, LightGray for descriptions, Yellow for node info, DarkGray for MOTD quote
- 80-column width throughout
- Title text centered within border box using padding calculation: `(78 - title.len()) / 2`

Update `backend/src/menu/mod.rs` to add:
```rust
pub mod render;
pub use render::{render_main_menu, render_submenu, render_help, BorderStyle};
```
  </action>
  <verify>
Run `cargo build` -- compiles cleanly.
Run `cargo test` -- all existing and new tests pass.
Add at least one test for render functions to verify they produce non-empty output containing expected ANSI sequences:
```rust
#[test]
fn test_render_main_menu_contains_title() {
    let config = MenuConfig::default();
    let output = render_main_menu(&config, 0, "TestUser", "User", Some(1), 16);
    assert!(output.contains("THE CONSTRUCT BBS"));
    assert!(output.contains("Your choice?"));
}
```
  </verify>
  <done>
render_main_menu produces full ANSI main menu with double-line header, MOTD quote, adaptive column layout, and user info. render_submenu produces submenu with single-line header and [Q] Back option. render_help shows context-sensitive help text. All rendering uses established AnsiWriter patterns with CP437 box-drawing and CGA colors.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds with all menu modules
2. `cargo test` passes (existing + new state machine + render tests)
3. MenuSession correctly transitions between MainMenu and Submenu states
4. TypeAheadBuffer handles FIFO push/pop with 16-char limit
5. render_main_menu produces double-line bordered menu with MOTD
6. render_submenu produces single-line bordered menu with Back option
7. render_help produces context-sensitive help for both states
</verification>

<success_criteria>
- State machine handles all input scenarios: submenu entry/exit, service launch, commands, help, redraw
- Type-ahead buffer enables command stacking (G1 = Games > item 1)
- Main menu displays with double-line borders, MOTD, user info, prompt
- Submenus display with single-line borders, items, Back option, prompt
- Help text accessible via '?' at any menu level
- All items level-gated and order-sorted
</success_criteria>

<output>
After completion, create `.planning/phases/03-navigation-system/03-02-SUMMARY.md`
</output>
