---
phase: 03-navigation-system
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - backend/src/services/menu.rs
  - backend/src/services/mod.rs
  - backend/src/websocket/session.rs
  - backend/src/services/welcome_art.rs
autonomous: true

must_haves:
  truths:
    - "User sees main menu with numbered/lettered options in Wildcat style after login"
    - "User can navigate to submenus by pressing hotkey (e.g., G for Games)"
    - "User can return from submenu to main menu with Q"
    - "User can use command stacking (e.g., G1 goes to Games > item 1)"
    - "Invalid input redraws the current menu"
    - "Enter alone redraws the current menu"
    - "User can press ? for help at any menu"
    - "Profile and Quit commands work from main menu"
    - "Menu items are filtered by user level"
    - "Single keypress navigation works (no Enter required for menu selection)"
    - "All menu screens display authentic ANSI art headers and borders"
    - "MOTD shows a Stoic quote between header and menu items"
  artifacts:
    - path: "backend/src/services/menu.rs"
      provides: "MenuService implementing navigation via MenuSession"
    - path: "backend/src/websocket/session.rs"
      provides: "Updated session to use MenuService for authenticated menu navigation"
      contains: "MenuSession"
  key_links:
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/menu/state.rs"
      via: "MenuSession for menu state management"
      pattern: "MenuSession"
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/menu/render.rs"
      via: "render functions for menu display"
      pattern: "render_main_menu|render_submenu|render_help"
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/menu/config.rs"
      via: "MenuConfig from AppState config"
      pattern: "config\\.menu"
---

<objective>
Integrate the menu navigation system into the session lifecycle, replacing the old main menu with the new Wildcat-style config-driven menu system.

Purpose: Wires up all the menu components (state machine, rendering, config) into the live session, making the navigation system fully functional for authenticated users. This is the "last mile" that makes everything work end-to-end.
Output: Users experience config-driven hierarchical menus with hotkey navigation, type-ahead buffering, MOTD quotes, and ANSI art headers immediately after login.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-navigation-system/03-CONTEXT.md
@.planning/phases/03-navigation-system/03-02-SUMMARY.md
@backend/src/websocket/session.rs
@backend/src/services/mod.rs
@backend/src/services/welcome_art.rs
@backend/src/menu/mod.rs
@backend/src/menu/state.rs
@backend/src/menu/render.rs
@backend/src/menu/config.rs
@backend/src/config.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Session integration with menu navigation system</name>
  <files>
    backend/src/websocket/session.rs
    backend/src/services/mod.rs
  </files>
  <action>
Integrate the MenuSession into the WebSocket session lifecycle. This replaces the old `show_main_menu` and `handle_authenticated_input` logic with the new config-driven menu system.

**Changes to Session struct (session.rs):**

Add a `menu_session: Option<MenuSession>` field to the Session struct. This is created when the user authenticates and holds the menu state for the session duration.

**Changes to authentication completion:**

In both `handle_awaiting_auth` (session resume) and `handle_login_input` (fresh login) and `handle_registration_input` (post-registration auto-login), after transitioning to `AuthState::Authenticated`:

1. Create a MenuSession: `MenuSession::new(user_level_num)` where user_level_num is parsed from the user level (0 for "User", 255 for "Sysop", etc. -- use a simple mapping).
2. Store it: `self.menu_session = Some(menu_session);`
3. Replace `self.show_main_menu().await` calls with the new `self.show_menu().await` method.

**New `show_menu` method:**

```rust
async fn show_menu(&mut self) {
    let menu_session = match &self.menu_session {
        Some(ms) => ms,
        None => return,
    };

    let (handle, user_level_name) = match &self.auth_state {
        AuthState::Authenticated { handle, user_level, .. } => {
            (handle.clone(), user_level.clone())
        }
        _ => return,
    };

    let max_nodes = self.state.config.connection.max_nodes as usize;

    let output = match menu_session.state() {
        MenuState::MainMenu => {
            menu::render::render_main_menu(
                &self.state.config.menu,
                menu_session.user_level(), // add getter
                &handle,
                &user_level_name,
                self.node_id,
                max_nodes,
            )
        }
        MenuState::Submenu { submenu_key } => {
            let items = self.state.config.menu.submenu_items(
                submenu_key,
                menu_session.user_level(),
            );
            let submenu_name = self.state.config.menu.submenu_name(submenu_key);
            menu::render::render_submenu(
                submenu_key,
                submenu_name,
                &items,
                menu_session.user_level(),
            )
        }
    };

    let _ = self.tx.send(output).await;
}
```

**Rewrite `handle_authenticated_input`:**

The core change: instead of matching trimmed input against service names/numbers, delegate to MenuSession for single-keypress navigation.

```rust
async fn handle_authenticated_input(&mut self, input: &str) {
    // Profile edit mode check (unchanged from Phase 2)
    if let Some(service_name) = &self.current_service {
        if service_name.starts_with("__profile_edit_") {
            self.handle_profile_edit_input(input).await;
            return;
        }
    }

    // Pagination check (unchanged)
    if self.pending_pages.is_some() {
        let trimmed = input.trim();
        if !trimmed.is_empty() && !trimmed.starts_with('\x1b') {
            self.send_next_page().await;
        }
        return;
    }

    // Profile menu check (unchanged)
    if let Some(service_name) = &self.current_service {
        if service_name == "__profile__" {
            self.handle_profile_menu_input(input).await;
            return;
        }
        // Currently in a service -- route input to it (unchanged from Phase 2)
        // ... existing service routing code stays ...
        return;
    }

    // AT MENU -- single keypress navigation
    for ch in input.chars() {
        // Skip escape sequences and control chars (except Enter)
        if ch == '\x1b' || (ch.is_control() && ch != '\r' && ch != '\n') {
            continue;
        }

        let action = {
            let menu_session = match &mut self.menu_session {
                Some(ms) => ms,
                None => return,
            };
            menu_session.process_key(ch, &self.state.config.menu)
        };

        match action {
            MenuAction::Redraw => {
                self.show_menu().await;
            }
            MenuAction::EnterSubmenu(_key) => {
                // State already transitioned in process_key
                // Brief pause for transition feel
                tokio::time::sleep(Duration::from_millis(200)).await;
                self.show_menu().await;
                // Process any buffered keys (command stacking)
                self.process_typeahead().await;
            }
            MenuAction::BackToMain => {
                tokio::time::sleep(Duration::from_millis(200)).await;
                self.show_menu().await;
            }
            MenuAction::LaunchService(service_name) => {
                // Echo the key
                let _ = self.tx.send(format!("{}", ch)).await;
                self.enter_service(&service_name).await;
                return; // Stop processing further chars
            }
            MenuAction::ExecuteCommand(cmd) => {
                match cmd.as_str() {
                    "quit" => {
                        // Echo 'Q'
                        let _ = self.tx.send(format!("{}", ch)).await;
                        self.handle_quit().await;
                        return;
                    }
                    "profile" => {
                        let _ = self.tx.send(format!("{}", ch)).await;
                        self.handle_profile_view().await;
                        return;
                    }
                    _ => {
                        // Unknown command, redraw
                        self.show_menu().await;
                    }
                }
            }
            MenuAction::ShowHelp => {
                let help = {
                    let ms = self.menu_session.as_ref().unwrap();
                    menu::render::render_help(
                        ms.state(),
                        &self.state.config.menu,
                        ms.user_level(),
                    )
                };
                let _ = self.tx.send(help).await;
                // After help, wait for any key then redraw menu
                // (Next input will trigger Redraw since help isn't a state)
            }
            MenuAction::Buffered | MenuAction::None => {
                // Do nothing
            }
        }
    }
}
```

**New helper: `process_typeahead`:**
```rust
async fn process_typeahead(&mut self) {
    let actions = {
        let ms = match &mut self.menu_session {
            Some(ms) => ms,
            None => return,
        };
        ms.drain_buffer(&self.state.config.menu)
    };
    for action in actions {
        match action {
            MenuAction::EnterSubmenu(_) => {
                tokio::time::sleep(Duration::from_millis(200)).await;
                self.show_menu().await;
            }
            MenuAction::LaunchService(svc) => {
                self.enter_service(&svc).await;
                return;
            }
            MenuAction::ExecuteCommand(cmd) => {
                match cmd.as_str() {
                    "quit" => { self.handle_quit().await; return; }
                    "profile" => { self.handle_profile_view().await; return; }
                    _ => {}
                }
            }
            MenuAction::Redraw => {
                self.show_menu().await;
            }
            _ => {}
        }
    }
}
```

**Refactor quit logic into `handle_quit` method:**
Extract the existing quit logic from `handle_authenticated_input` (the `trimmed.eq_ignore_ascii_case("quit")` block) into a new `async fn handle_quit(&mut self)` method. This keeps the code DRY since it's now called from both the menu action handler and potentially type-ahead processing.

**Refactor profile logic into `handle_profile_view` method:**
Extract the existing profile view logic into `async fn handle_profile_view(&mut self)`. Same reason.

**Service exit returns to menu:**
When a service exits (ServiceAction::Exit in the existing service routing code), call:
```rust
if let Some(ms) = &mut self.menu_session {
    ms.reset_to_main();
}
self.show_menu().await;
```
instead of the old `self.show_main_menu().await`.

**Key behavioral requirements:**
- Single keypress: Each char in input is processed immediately through process_key. No waiting for Enter for menu selection (Enter triggers Redraw).
- Key echo: When a menu selection is made (service launch, command), echo the pressed character before acting.
- Invalid input: Produces Redraw action which clears and redraws the full menu.
- Empty submenus: If a submenu has no visible items (all filtered out or all commented out), show the submenu header with a "No items available" message and the [Q] Back option.
- Command stacking: When EnterSubmenu fires, drain_buffer processes remaining keys against the new submenu state.

**Add `use crate::menu;` to session.rs imports.**
Update services/mod.rs if needed (no new Service trait impl needed -- MenuSession is used directly in session, not through the Service trait).
  </action>
  <verify>
Run `cargo build` -- must compile cleanly.
Run `cargo test` -- all tests pass.
Manual verification flow (start the server with `cargo run`):
1. Connect via browser, log in
2. Main menu appears with double-line box, MOTD quote, menu items (G/M/C/N/P/Q)
3. Press 'G' -- Games submenu appears with single-line box, "[Q] Back to Main Menu"
4. Press 'Q' -- returns to main menu
5. Press 'P' -- profile card appears
6. Press 'Q' from profile -- returns to main menu
7. Press '?' -- help screen appears
8. Press any key -- returns to menu
9. Press Enter alone -- menu redraws
10. Press invalid key (e.g., 'X') -- menu redraws
11. Press 'Q' from main menu -- goodbye sequence and disconnect
  </verify>
  <done>
Authenticated users navigate via MenuSession with single-keypress hotkeys. Main menu shows config-driven items with MOTD. Submenus accessible via hotkey with [Q] Back. Command stacking works via type-ahead buffer. Profile and Quit commands function from main menu. Service launch/exit correctly transitions menu state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Clean up legacy menu code and verify end-to-end</name>
  <files>
    backend/src/services/welcome_art.rs
    backend/src/websocket/session.rs
  </files>
  <action>
Clean up the legacy Phase 2 main menu rendering and ensure all paths work cleanly.

**welcome_art.rs changes:**
- Keep `render_welcome()` (the Phase 1 welcome/test screen -- still useful for non-authenticated display)
- Remove or deprecate `render_main_menu_with_user()` and `render_main_menu()` since they are replaced by `menu::render::render_main_menu()`. If any code still references them, update those references. Mark with `#[deprecated]` or remove entirely if no references remain.

**session.rs cleanup:**
- Remove the old `show_main_menu()` method entirely (replaced by `show_menu()`)
- Verify all paths that previously called `show_main_menu()` now call `show_menu()`:
  - After successful login (handle_login_input -> LoginResult::Success)
  - After successful registration (handle_registration_input -> RegistrationResult::Complete)
  - After session resume (handle_awaiting_auth -> valid token)
  - After service exit (ServiceAction::Exit)
  - After profile menu exit ('q' in handle_profile_menu_input)
  - After profile edit completion
- Ensure that when user returns from a service, the menu state is reset to MainMenu via `menu_session.reset_to_main()` before showing menu.
- Remove the old service-number/name matching code from handle_authenticated_input (the `services.iter()`, `parse::<usize>()`, and name-match blocks).
- Make sure `enter_service` still works -- it should be unchanged since services are launched by name from MenuAction::LaunchService.

**Edge cases to verify:**
1. Empty submenu (Games has all items commented out): should show "No services available yet" message inside submenu + [Q] Back
2. User with level 0 (normal user) should not see min_level > 0 items
3. After service exit, menu resets to MainMenu (not Submenu)
4. Type-ahead buffer clears on service launch/command execution
5. Help screen doesn't change menu state (pressing '?' then any key returns to same menu)

**Final verification:**
Ensure `cargo build` and `cargo test` both pass. Run the server and manually test the full flow: connect -> ceremony -> login -> main menu -> submenu -> back -> profile -> back -> quit.
  </action>
  <verify>
Run `cargo build` -- compiles cleanly with no warnings about unused functions.
Run `cargo test` -- all tests pass.
Run `cargo clippy` (if available) for lint check.
Verify no dead code warnings related to old menu functions.
Start server and test full navigation flow:
1. Fresh login -> main menu with MOTD
2. G -> Games submenu (empty, shows message)
3. Q -> back to main
4. P -> profile card with edit menu
5. Q -> back to main
6. ? -> help screen
7. Any key -> back to main
8. Q -> goodbye + disconnect
  </verify>
  <done>
Legacy menu code removed. All session paths use new MenuSession-based navigation. Empty submenus handled gracefully. Service exit resets to MainMenu. No dead code or compilation warnings. Full navigation lifecycle works end-to-end: login -> menu -> submenu -> back -> profile -> quit.
  </done>
</task>

</tasks>

<verification>
Phase 3 success criteria verification:
1. "User sees main menu with numbered/lettered options in Wildcat style" -- Main menu renders with hotkey items from config.toml
2. "User can navigate hierarchical menu structure with breadcrumbs" -- Submenus accessible via hotkey, [Q] Back returns to main
3. "User can use hotkeys for rapid menu traversal" -- Single keypress, command stacking via type-ahead buffer
4. "All menu screens display authentic ANSI art headers and borders" -- Double-line main, single-line submenus, MOTD quotes

Additional checks:
- Config.toml defines all menu entries with proper types and ordering
- Level-gating filters items before rendering
- Help accessible via '?' at all menu levels
- Invalid input and Enter redraw current menu
- Profile and Quit commands work from main menu
- Service launch and exit work with menu state transitions
</verification>

<success_criteria>
- Authenticated users see config-driven Wildcat-style menu immediately after login
- All menu navigation works via single keypress (no Enter required for selection)
- Command stacking (e.g., G1) navigates through menus in sequence
- Main menu: double-line ANSI header, MOTD quote, hotkey items, user info, prompt
- Submenus: single-line header, items, [Q] Back to Main Menu
- Help: accessible via '?' with context-sensitive content
- Profile and Quit: functional from main menu
- Empty submenus: graceful message instead of blank screen
- All existing functionality (login, registration, ceremony, profile edit) unbroken
</success_criteria>

<output>
After completion, create `.planning/phases/03-navigation-system/03-03-SUMMARY.md`
</output>
