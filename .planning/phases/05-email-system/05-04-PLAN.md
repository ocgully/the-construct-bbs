---
phase: 05-email-system
plan: 04
type: execute
wave: 3
depends_on: ["05-01"]
files_modified:
  - backend/src/connection/timer.rs
  - frontend/src/status-bar.ts
  - frontend/src/timer.ts
  - frontend/src/websocket.ts
autonomous: true

must_haves:
  truths:
    - "Status bar shows MAIL indicator when user has unread messages"
    - "MAIL indicator updates periodically (on timer ticks) without user action"
    - "MAIL indicator disappears when all messages are read"
    - "User can access Mail from main menu with M hotkey"
  artifacts:
    - path: "backend/src/connection/timer.rs"
      provides: "Timer sends has_mail flag in timer JSON messages"
      contains: "has_mail"
    - path: "frontend/src/status-bar.ts"
      provides: "Status bar renders MAIL indicator"
      contains: "MAIL"
    - path: "frontend/src/timer.ts"
      provides: "Timer handler passes has_mail to status bar"
      contains: "hasMail"
  key_links:
    - from: "backend/src/connection/timer.rs"
      to: "backend/src/db/messages.rs"
      via: "get_unread_count on each timer tick"
      pattern: "get_unread_count"
    - from: "frontend/src/timer.ts"
      to: "frontend/src/status-bar.ts"
      via: "passes hasMail boolean to status bar update"
      pattern: "hasMail"
---

<objective>
Add MAIL indicator to the status bar that appears when the user has unread messages.

Purpose: Users need a persistent visual indicator of new mail without having to check their inbox. The status bar already shows handle, online count, and time remaining - adding a MAIL flag extends it naturally.
Output: Backend timer sends has_mail flag, frontend status bar renders "MAIL" indicator.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-email-system/05-RESEARCH.md
@.planning/phases/05-email-system/05-01-SUMMARY.md

@backend/src/connection/timer.rs
@frontend/src/status-bar.ts
@frontend/src/timer.ts
@frontend/src/websocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend timer sends has_mail flag</name>
  <files>
    backend/src/connection/timer.rs
  </files>
  <action>
Modify the timer to include a `has_mail` boolean in its JSON timer messages. The timer already ticks every minute (or every second in final minute), so checking unread count is low overhead.

1. Add parameter to `SessionTimer::spawn()`:
   - `user_id: i64` - needed to check unread messages
   - `pool: SqlitePool` (or Arc<SqlitePool>) - needed for DB queries

   Update the spawn signature and pass these to the run_timer async function.

2. In `run_timer()`, add `user_id` and `pool` parameters.

3. On each timer tick (both per-minute and per-second), check for unread mail:
```rust
use crate::db::messages::get_unread_count;

let has_mail = match get_unread_count(&pool, user_id).await {
    Ok(count) => count > 0,
    Err(_) => false, // Fail silently - don't break timer for mail check
};
```

4. Add `"has_mail": has_mail` to ALL timer JSON messages (initial, per-minute, per-second, unlimited). This includes:
   - Initial time update message
   - Per-minute tick messages
   - Per-second tick messages (final minute)
   - Unlimited time initial message

The JSON now looks like:
```json
{
    "type": "timer",
    "remaining": 55,
    "unit": "min",
    "warning": "normal",
    "handle": "TestUser",
    "online": 3,
    "has_mail": true
}
```

5. Update all callers of SessionTimer::spawn() in session.rs to pass user_id and pool. The session already has access to both via self.state.pool and the user_id from AuthState::Authenticated.

IMPORTANT: The unread check query (SELECT COUNT(*) WHERE recipient_id = ? AND is_read = 0) is indexed and fast. Running it per-minute is negligible overhead. During the final minute (per-second ticks), it runs more frequently but only for ~60 seconds - acceptable for a BBS with small user counts.

NOTE on per-second optimization: During the final minute, you could skip the mail check or cache it to avoid 60 queries in 60 seconds. Simple approach: check once at the start of the final minute phase and use cached value for per-second ticks. This is optional but good practice.
  </action>
  <verify>
Run `cargo check` to verify timer compiles with new parameters. Run `cargo test` to verify existing timer tests still pass (may need to update test setup to provide pool/user_id). Start the BBS and verify timer JSON messages include has_mail field via browser dev tools Network/WebSocket tab.
  </verify>
  <done>
Timer sends has_mail boolean in all timer JSON messages. Unread check runs on each per-minute tick. All callers of SessionTimer::spawn updated with user_id and pool parameters.
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend status bar MAIL indicator and menu config</name>
  <files>
    frontend/src/status-bar.ts
    frontend/src/timer.ts
    frontend/src/websocket.ts
    config.toml
  </files>
  <action>
1. Update StatusBar class (frontend/src/status-bar.ts):

   Add `hasMail` property:
   ```typescript
   private hasMail: boolean = false;
   ```

   Add to `update()` method opts:
   ```typescript
   hasMail?: boolean;
   ```
   And in the method body:
   ```typescript
   if (opts.hasMail !== undefined) this.hasMail = opts.hasMail;
   ```

   Update `render()` method to include MAIL indicator:
   - Place "MAIL" text between the handle (left) and online count (center)
   - Only show when this.hasMail is true
   - Style: Yellow bold "MAIL" text (use \x1b[33m\x1b[1m for yellow bold)
   - Example bar layout: ` TestUser  MAIL          Online: 3          Time: 55m `
   - When no mail: ` TestUser                Online: 3          Time: 55m `
   - Adjust spacing calculation to account for "MAIL" text (5 chars including space)

2. Update SessionTimer class (frontend/src/timer.ts):

   In `updateFromServer()`, extract has_mail from server data:
   ```typescript
   updateFromServer(data: {
       remaining: number;
       unit: string;
       warning: string;
       handle: string;
       online: number;
       has_mail?: boolean;  // New field
   }) {
   ```

   Pass hasMail to statusBar.update():
   ```typescript
   this.statusBar.update({
       handle: data.handle,
       online: data.online,
       timeDisplay: this.formatTime(),
       warning: warning,
       hasMail: data.has_mail || false,
   });
   ```

   Also update the hasMail in the unlimited time path.

3. Update websocket.ts if needed: Check if the timer message parsing needs updating. The websocket handler should already pass the full data object to SessionTimer.updateFromServer(), so has_mail should flow through automatically. Verify this and update if the data is destructured before passing.

4. Update config.toml to uncomment and activate mail submenu items:

   Replace the commented-out mail section with active entries. Based on the user context, the mail experience should be a single "Mail" entry on the main menu that goes to an inbox view (not a submenu with separate Read/Send items). The context describes:
   - User accesses Mail from main menu -> sees inbox
   - Inbox has [C]ompose option built in

   So the simplest approach: Make the "M" hotkey on the main menu a command that opens the mail inbox directly, rather than a submenu. Change the existing main menu entry from submenu to command:

   ```toml
   [[menu.main]]
   type = "command"
   hotkey = "M"
   name = "Mail"
   command = "mail"
   order = 2
   ```

   Remove (or leave commented) the mail submenu items since the inbox view itself handles compose/read navigation.

   This requires the "mail" command handler in session.rs (added in Plan 05-03 Task 1) to be present. Plan 05-03 adds `"mail" => { self.show_inbox().await; return; }` to the MenuAction::ExecuteCommand match blocks.

IMPORTANT: The MAIL indicator color must use the existing ANSI escape sequences compatible with xterm.js. Yellow bold: \x1b[33m\x1b[1m. Reset after: use the current bar's bg/fg colors.

Also build the frontend after changes: run `npm run build` from the frontend directory to generate updated dist files.
  </action>
  <verify>
Run `npm run build` in frontend directory to verify TypeScript compiles. Start the BBS and verify:
1. Status bar shows "MAIL" when user has unread messages
2. "MAIL" disappears after all messages are read
3. Mail menu item "M" works from main menu and opens inbox
4. Status bar layout remains 80 columns with proper spacing
  </verify>
  <done>
Status bar displays Yellow bold "MAIL" indicator when has_mail is true. MAIL indicator updates on each timer tick. Frontend compiles successfully. Mail menu item routes to inbox. Config.toml updated with mail command entry.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes in backend directory
2. `npm run build` passes in frontend directory
3. Timer JSON messages include has_mail boolean
4. Status bar shows/hides MAIL indicator based on unread state
5. Mail accessible from main menu via "M" hotkey
6. config.toml has active mail menu entry
7. All existing tests pass
</verification>

<success_criteria>
- Backend timer includes has_mail in all timer messages
- Frontend status bar renders "MAIL" in Yellow bold when unread messages exist
- MAIL indicator disappears when inbox is empty or all read
- Mail accessible from main menu via M hotkey
- 80-column status bar layout preserved with MAIL indicator
- Frontend builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-email-system/05-04-SUMMARY.md`
</output>
