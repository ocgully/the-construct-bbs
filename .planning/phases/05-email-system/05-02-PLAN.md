---
phase: 05-email-system
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - backend/src/services/mail.rs
  - backend/src/services/mod.rs
autonomous: true

must_haves:
  truths:
    - "Inbox renders as ANSI table with # | From | Subject | Date | Status(N/R) columns"
    - "Message view displays full content with sender, date, subject, body and action bar"
    - "Compose state machine handles To -> Subject -> Body flow with line-by-line editing"
    - "Reply pre-populates quoted original with > prefix and Re: subject"
  artifacts:
    - path: "backend/src/services/mail.rs"
      provides: "Mail rendering functions and ComposeState machine"
      exports: ["render_inbox", "render_message", "render_compose_prompt", "ComposeState", "ComposeFlow"]
  key_links:
    - from: "backend/src/services/mail.rs"
      to: "backend/src/db/messages.rs"
      via: "uses Message and InboxEntry types"
      pattern: "use crate::db::messages"
    - from: "backend/src/services/mail.rs"
      to: "backend/src/terminal"
      via: "AnsiWriter for ANSI rendering"
      pattern: "use crate::terminal"
---

<objective>
Create the mail service module with ANSI rendering functions and the compose state machine.

Purpose: This module provides all the visual output (inbox table, message view, compose prompts) and the compose flow state machine that session.rs will drive. Separating rendering and state logic from session integration keeps both plans focused.
Output: services/mail.rs with render functions and ComposeFlow struct.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-email-system/05-RESEARCH.md
@.planning/phases/05-email-system/05-01-SUMMARY.md

@backend/src/services/profile.rs
@backend/src/services/who.rs
@backend/src/services/mod.rs
@backend/src/terminal/writer.rs
@backend/src/db/messages.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Mail ANSI rendering functions</name>
  <files>
    backend/src/services/mail.rs
    backend/src/services/mod.rs
  </files>
  <action>
Create backend/src/services/mail.rs with rendering functions following the patterns established in profile.rs (CP437 box-drawing, CGA colors) and who.rs (table layout).

1. `render_inbox(entries, page, total_count, page_size, sender_handles) -> String`:
   - CP437 double-line box header: "MAIL INBOX" title in Yellow bold
   - Column headers: #(3) | From(18) | Subject(33) | Date(12) | St(2) = ~75 data cols + 5 borders = 80 total
   - For each entry: message number (page * page_size + idx + 1), sender handle from lookup, truncated subject, formatted date, status indicator
   - Unread: Yellow bold number with "N" marker. Read: LightGray number with space
   - Footer with page info: "Page X of Y (Z messages)"
   - Action bar: [#] Read  [C] Compose  [N] Next  [P] Prev  [Q] Quit
   - Use AnsiWriter for all ANSI output
   - Use format_date helper from profile.rs (import or replicate the date formatting logic)
   - Handle empty inbox: show "No messages." inside the box

2. `render_message(msg: &Message, sender_handle: &str) -> String`:
   - CP437 double-line box header
   - From: sender_handle (Yellow bold)
   - Date: formatted sent_at (LightGray)
   - Subject: msg.subject (White bold)
   - Separator line (single-line)
   - Body: msg.body with \n converted to \r\n for terminal display (White on Black)
   - Action bar at bottom: [R]eply  [D]elete  [N]ext  [Q]uit to inbox
   - Use AnsiWriter

3. `render_compose_header(recipient_handle: &str) -> String`:
   - Small ANSI header: "COMPOSE MESSAGE"
   - Shows "To: {recipient_handle}" in Yellow

4. `render_new_mail_notification(unread_count: i64) -> String`:
   - Yellow bold: "*** You have {N} new message(s). ***"
   - Only called when unread_count > 0
   - Pluralize "message" vs "messages"

5. `render_mailbox_full_error() -> String`:
   - Red text: "Recipient's mailbox is full. Message not sent."

6. `render_self_mail_error() -> String`:
   - Red text: "You cannot send mail to yourself."

7. `render_user_not_found_error(handle: &str) -> String`:
   - Red text: "User '{handle}' not found."

Register module in services/mod.rs: add `pub mod mail;`

IMPORTANT PATTERNS:
- Follow CGA 16-color palette (no RGB colors)
- Use \r\n for all line endings in terminal output
- LightCyan for box borders (consistent with profile.rs, who.rs)
- Yellow for highlights, White bold for data headers
- LightGray for secondary text
- All render functions return String (not writing directly to session)
  </action>
  <verify>
Run `cargo check` to verify all render functions compile. Run `cargo test` to verify no regressions.
  </verify>
  <done>
All render functions compile and return ANSI-formatted strings. Module registered in services/mod.rs. Inbox table uses 80-column layout with proper box-drawing characters.
  </done>
</task>

<task type="auto">
  <name>Task 2: Compose state machine with line-by-line editor</name>
  <files>
    backend/src/services/mail.rs
  </files>
  <action>
Add the ComposeFlow struct and state machine to mail.rs, following the pattern from LoginFlow/RegistrationFlow (character-by-character input with handle_char and handle_input).

1. Define ComposeState enum:
```rust
enum ComposeState {
    PromptTo,
    InputTo,
    PromptSubject,
    InputSubject,
    PromptBody,
    InputBody,
    Sending,
    Done,
    Aborted,
}
```

2. Define ComposeFlow struct:
```rust
pub struct ComposeFlow {
    state: ComposeState,
    sender_id: i64,
    sender_handle: String,
    input_buffer: String,
    recipient_id: Option<i64>,
    recipient_handle: Option<String>,
    subject: Option<String>,
    body_lines: Vec<String>,
    is_reply: bool,
}
```

3. Implement ComposeFlow:

- `new(sender_id, sender_handle) -> Self`: Start at PromptTo state
- `new_reply(sender_id, sender_handle, recipient_id, recipient_handle, original_subject, original_body) -> Self`: Start at PromptBody with:
  - recipient pre-filled
  - subject auto-set to "Re: {original_subject}" (check starts_with("Re: ") to prevent "Re: Re: Re:" accumulation)
  - body_lines pre-filled with quoted original (each line prefixed with "> ")
  - is_reply = true

- `current_prompt() -> &str`: Returns current prompt text based on state:
  - PromptTo: "To: "
  - PromptSubject: "Subject: "
  - PromptBody: "Enter message. /s to send, /a to abort, /h for help:\r\n"

- `handle_char(ch: char) -> ComposeAction`: Character-by-character processing:
  - Backspace (0x08 or 0x7F): remove last char from input_buffer, return Echo("\x08 \x08")
  - Printable char: append to input_buffer, return Echo(ch)
  - Enter (\r or \n): process completed line via handle_line(), return appropriate action
  - Max buffer length: 254 chars for To/Subject, unlimited for body lines

- `handle_line() -> ComposeAction`: Process completed input_buffer:
  - InputTo state: take input_buffer as recipient handle (trimmed). Return NeedRecipientLookup(handle) so session can do async DB lookup.
  - InputSubject state: take input_buffer as subject. Transition to PromptBody. Return ShowPrompt(body_prompt).
  - InputBody state:
    - If line starts with "/s" or "/S": transition to Sending, return SendMessage { recipient_id, subject, body }
    - If line starts with "/a" or "/A": transition to Aborted, return Aborted
    - If line starts with "/h" or "/H": return ShowHelp (display /s, /a, /l commands)
    - If line starts with "/l" or "/L": return ShowLines (display current body_lines with line numbers)
    - Otherwise: push line to body_lines, return Continue

- `set_recipient(id, handle)`: Called by session after successful DB lookup. Sets recipient_id and recipient_handle, transitions to PromptSubject (or PromptBody if is_reply).

- `set_recipient_error(msg)`: Called by session when handle not found. Stays in PromptTo.

- `get_body() -> String`: Join body_lines with "\n" (LF for storage, session converts to CRLF for display)

4. Define ComposeAction enum (returned by handle_char/handle_line):
```rust
pub enum ComposeAction {
    Continue,
    Echo(String),
    ShowPrompt(String),
    NeedRecipientLookup(String),
    SendMessage { recipient_id: i64, recipient_handle: String, subject: String, body: String },
    Aborted,
    ShowHelp,
    ShowLines(String),
}
```

5. Add helper function `render_compose_help() -> String`:
   - Yellow text listing available commands: /s Send, /a Abort, /h Help, /l List lines

6. Add helper function `format_body_lines(lines: &[String]) -> String`:
   - Number each line and display for /l command

IMPORTANT:
- Do NOT do async DB operations inside ComposeFlow. Return ComposeAction::NeedRecipientLookup and let session.rs handle the async lookup.
- The flow is synchronous state machine; async operations happen in session.rs.
- Self-mail check happens in session.rs when processing NeedRecipientLookup (compare sender_id with looked-up recipient_id).
  </action>
  <verify>
Run `cargo check` to verify ComposeFlow and all types compile. Run `cargo test` to verify no regressions.
  </verify>
  <done>
ComposeFlow state machine handles full To -> Subject -> Body flow. Reply mode pre-fills recipient, subject (with Re: dedup), and quoted body. All slash commands (/s, /a, /h, /l) handled. ComposeAction enum enables async session integration without blocking.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes in backend directory
2. `cargo test` passes with no regressions
3. render_inbox produces valid ANSI output with 80-column table
4. render_message displays full message with action bar
5. ComposeFlow transitions through all states correctly
6. Reply mode prevents "Re: Re:" accumulation
7. All render functions return String
</verification>

<success_criteria>
- services/mail.rs exists with render_inbox, render_message, render_compose_header, ComposeFlow, ComposeAction
- Module registered in services/mod.rs
- ComposeFlow handles normal compose and reply compose paths
- Slash commands (/s, /a, /h, /l) recognized in body input
- All functions compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-email-system/05-02-SUMMARY.md`
</output>
