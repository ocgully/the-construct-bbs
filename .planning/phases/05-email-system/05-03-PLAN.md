---
phase: 05-email-system
plan: 03
type: execute
wave: 3
depends_on: ["05-01", "05-02"]
files_modified:
  - backend/src/websocket/session.rs
autonomous: true

must_haves:
  truths:
    - "User can open inbox from menu and see paginated message list with unread markers"
    - "User can type a message number to read a message, and it gets marked as read"
    - "User can compose a new message via [C] from inbox, with To/Subject/Body prompts"
    - "User can reply to a message with [R] from message view, with quoted original"
    - "User can delete a message with [D] from message view"
    - "User sees 'You have X new messages' notification after login"
    - "Mailbox full check prevents sending when recipient is at limit"
  artifacts:
    - path: "backend/src/websocket/session.rs"
      provides: "Sentinel service handlers for __mail_inbox__, __mail_read__, __mail_compose__ and login notification"
      contains: "__mail_inbox__"
  key_links:
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/services/mail.rs"
      via: "imports render functions and ComposeFlow"
      pattern: "use crate::services::mail"
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/db/messages.rs"
      via: "CRUD operations for inbox, read, compose, delete"
      pattern: "use crate::db::messages"
    - from: "session.rs __mail_inbox__"
      to: "render_inbox"
      via: "sentinel service handler calls render function"
      pattern: "__mail_inbox__.*render_inbox"
    - from: "session.rs __mail_compose__"
      to: "ComposeFlow"
      via: "compose handler drives state machine"
      pattern: "__mail_compose__.*ComposeFlow"
---

<objective>
Wire mail functionality into the session lifecycle with sentinel service handlers and login notification.

Purpose: This is the core integration plan that makes mail actually work. It connects the DB layer (Plan 01) and rendering/compose logic (Plan 02) to user input via the established sentinel service pattern.
Output: Working inbox navigation, message reading, compose/reply/delete flows, and login notification in session.rs.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-email-system/05-RESEARCH.md
@.planning/phases/05-email-system/05-01-SUMMARY.md
@.planning/phases/05-email-system/05-02-SUMMARY.md

@backend/src/websocket/session.rs
@backend/src/db/messages.rs
@backend/src/services/mail.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sentinel service handlers for mail views</name>
  <files>
    backend/src/websocket/session.rs
  </files>
  <action>
Add mail sentinel service handlers to session.rs following the established pattern from __whos_online__, __last_callers__, __user_lookup__, __profile__.

**Add to Session struct:**
- `mail_page: usize` - current inbox page number (default 0)
- `mail_compose: Option<ComposeFlow>` - active compose flow (None when not composing)
- `mail_reading_id: Option<i64>` - ID of message currently being read (for reply/delete context)

**Add imports:**
- `use crate::db::messages::{...all CRUD functions...};`
- `use crate::services::mail::{...all render functions and ComposeFlow, ComposeAction...};`

**Add handler in handle_authenticated_input (after existing sentinel handlers):**

1. `__mail_inbox__` handler:
   - Parse input character by character:
     - 'c' or 'C': Start compose flow - create new ComposeFlow, set current_service to "__mail_compose__", show "To: " prompt
     - 'n' or 'N': Increment mail_page, re-render inbox (clamp to max page)
     - 'p' or 'P': Decrement mail_page (clamp to 0), re-render inbox
     - 'q' or 'Q': Clear current_service (back to menu), reset mail_page to 0
     - Digit chars: Accumulate in an input buffer. On Enter, parse as message number, validate range, fetch message by ID from the current page's entries, set current_service to "__mail_read__" with mail_reading_id, mark message as read, render message view
   - For digit input: Need a small input buffer. Reuse the existing pattern (or add a mail_input_buffer: Option<String> to Session)
   - When entering inbox: Fetch inbox page from DB (get_inbox_page), fetch sender handles (get_sender_handles), get total count (get_inbox_count), render with render_inbox

2. `__mail_read__` handler:
   - Single-char input:
     - 'r' or 'R': Start reply flow - fetch the current message (mail_reading_id), create ComposeFlow::new_reply with original message data, set current_service to "__mail_compose__", show quoted text and body prompt
     - 'd' or 'D': Delete message (delete_message with mail_reading_id and user_id), show confirmation "Message deleted.", return to inbox (re-render inbox, set current_service to "__mail_inbox__")
     - 'n' or 'N': Go to next message - calculate next message ID in current page, if exists show it, if at end of page try next page, if no more messages return to inbox
     - 'q' or 'Q': Return to inbox (re-render, set current_service to "__mail_inbox__")

3. `__mail_compose__` handler:
   - Route ALL input through ComposeFlow character-by-character:
     - For each character in input: call compose_flow.handle_char(ch)
     - Process returned ComposeAction:
       - Echo(s): Write s to output_buffer
       - ShowPrompt(s): Write s to output_buffer
       - NeedRecipientLookup(handle): Do async find_user_by_handle lookup. If found and not self: call compose_flow.set_recipient(id, handle), show subject prompt. If self: show self-mail error, re-prompt. If not found: show user-not-found error, re-prompt.
       - SendMessage { recipient_id, subject, body }: Check mailbox full (check_mailbox_full). If full: show mailbox-full error. If OK: create_message in DB, increment sender's messages_sent counter (update_user_field), show "Message sent to {handle}." success, return to inbox. Set current_service to "__mail_inbox__".
       - Aborted: Show "Message aborted.", return to inbox. Set current_service to "__mail_inbox__".
       - ShowHelp: Write compose help text
       - ShowLines(s): Write line listing

**Add helper method `show_inbox(&mut self)`:**
- Fetches inbox page, sender handles, total count from DB
- Calls render_inbox and writes to output_buffer
- Sets current_service to "__mail_inbox__"

IMPORTANT PATTERNS:
- Follow exact same sentinel pattern as __whos_online__ etc: check service_name string match, process input, return Ok(())
- All DB operations are async - use self.state.pool for database access
- Write output via self.output_buffer.write_str() or self.tx.send()
- After any screen change, the status bar may need refresh - existing patterns handle this
- Self-mail validation: compare sender user_id with looked-up recipient user_id, NOT handles (handles could have case differences)
  </action>
  <verify>
Run `cargo check` to verify all handlers compile. Run `cargo test` to verify no regressions. Manually test by running the BBS and navigating to Mail from menu (will need Plan 04 for menu wiring, but the handlers should compile).
  </verify>
  <done>
All three sentinel handlers (__mail_inbox__, __mail_read__, __mail_compose__) implemented in handle_authenticated_input. Inbox shows paginated message list. Messages can be read, replied to, and deleted. Compose flow drives ComposeFlow state machine with async DB lookups. Self-mail and mailbox-full checks enforced.
  </done>
</task>

<task type="auto">
  <name>Task 2: Login notification for new mail</name>
  <files>
    backend/src/websocket/session.rs
  </files>
  <action>
Add new-mail notification to the login flow in session.rs.

1. Find the three authentication success paths in session.rs:
   - Login success (after render_welcome_back)
   - Registration success (after creating account)
   - Session resume (after resuming from token)

2. After each authentication success path, BEFORE showing the main menu, add an unread mail check:

```rust
// Check for new mail
if let Ok(unread) = get_unread_count(&self.state.pool, user_id).await {
    if unread > 0 {
        let notification = render_new_mail_notification(unread);
        self.output_buffer.write_str(&notification);
    }
}
```

3. This should appear AFTER the welcome-back message and BEFORE the main menu render. The notification is informational only - no prompt to read.

4. For registration (brand new user): skip the check since they can't have mail yet. Or let it run - it will return 0 unread and show nothing. The latter is simpler and more consistent.

IMPORTANT: The notification must use render_new_mail_notification from services/mail.rs. The function returns a formatted ANSI string with Yellow bold "*** You have X new message(s). ***" text.
  </action>
  <verify>
Run `cargo check` to verify compilation. Run `cargo test` to verify no regressions. Start the BBS, create two users, send a message from one to the other, log in as recipient - should see "You have 1 new message." notification.
  </verify>
  <done>
Login notification shows unread mail count after authentication in all three auth paths (login, resume, registration). Notification appears between welcome-back message and main menu. Zero unread shows nothing.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes in backend directory
2. `cargo test` passes with no regressions
3. Mail sentinel handlers route input correctly for inbox, read, and compose views
4. Compose flow handles To -> Subject -> Body with character-by-character input
5. Reply pre-fills quoted text and Re: subject
6. Delete removes message and returns to inbox
7. Self-mail blocked at compose time
8. Mailbox full check prevents sending
9. Login notification shows unread count
</verification>

<success_criteria>
- __mail_inbox__ sentinel shows paginated inbox with navigation (C/N/P/Q/number)
- __mail_read__ sentinel shows message with actions (R/D/N/Q)
- __mail_compose__ sentinel drives ComposeFlow state machine
- Login notification displays "You have X new message(s)." after auth
- Self-mail and mailbox-full validations enforced
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-email-system/05-03-SUMMARY.md`
</output>
