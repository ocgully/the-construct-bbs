---
phase: 05-email-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/schema.sql
  - backend/src/db/messages.rs
  - backend/src/db/mod.rs
  - backend/src/config.rs
autonomous: true

must_haves:
  truths:
    - "Messages table exists in SQLite with sender/recipient foreign keys and CASCADE delete"
    - "CRUD operations for messages work correctly (create, read inbox page, count unread, mark read, delete)"
    - "MailConfig section is available in config.toml with mailbox_size_limit defaulting to 100"
  artifacts:
    - path: "backend/src/db/messages.rs"
      provides: "Message struct and all CRUD functions"
      exports: ["Message", "create_message", "get_inbox_page", "get_inbox_count", "get_unread_count", "get_message_by_id", "mark_message_read", "delete_message", "get_sender_handles"]
    - path: "backend/src/db/schema.sql"
      provides: "Messages table DDL with foreign keys and indexes"
      contains: "CREATE TABLE IF NOT EXISTS messages"
    - path: "backend/src/config.rs"
      provides: "MailConfig struct with mailbox_size_limit"
      contains: "pub struct MailConfig"
  key_links:
    - from: "backend/src/db/messages.rs"
      to: "backend/src/db/schema.sql"
      via: "sqlx string queries matching schema columns"
      pattern: "SELECT.*FROM messages"
    - from: "backend/src/config.rs"
      to: "config.toml"
      via: "serde deserialization"
      pattern: "MailConfig"
---

<objective>
Create the database foundation and configuration for the BBS email system.

Purpose: All mail features depend on the messages table and CRUD operations. This plan establishes the data layer that Plans 02-04 build upon.
Output: Messages table in schema.sql, full CRUD in db/messages.rs, MailConfig in config.rs with config.toml section.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-email-system/05-RESEARCH.md

@backend/src/db/schema.sql
@backend/src/db/user.rs
@backend/src/db/mod.rs
@backend/src/config.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Messages table schema and CRUD operations</name>
  <files>
    backend/src/db/schema.sql
    backend/src/db/messages.rs
    backend/src/db/mod.rs
  </files>
  <action>
1. Add messages table to schema.sql (after session_history table):

```sql
CREATE TABLE IF NOT EXISTS messages (
    id INTEGER PRIMARY KEY,
    sender_id INTEGER NOT NULL,
    recipient_id INTEGER NOT NULL,
    subject TEXT NOT NULL,
    body TEXT NOT NULL,
    sent_at TEXT NOT NULL DEFAULT (datetime('now', '-5 hours')),
    is_read INTEGER NOT NULL DEFAULT 0,
    FOREIGN KEY (sender_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (recipient_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_messages_recipient ON messages(recipient_id, sent_at DESC);
CREATE INDEX IF NOT EXISTS idx_messages_sender ON messages(sender_id, sent_at DESC);
```

2. Create backend/src/db/messages.rs with these functions, following the string-based sqlx query pattern from db/user.rs:

- `Message` struct (derive Debug, Clone, FromRow): id (i64), sender_id (i64), recipient_id (i64), subject (String), body (String), sent_at (String), is_read (i32)

- `create_message(pool, sender_id, recipient_id, subject, body) -> Result<i64, sqlx::Error>`: INSERT and return last_insert_rowid. Validate sender_id != recipient_id before insert (return sqlx::Error::Protocol if self-mail). Normalize body newlines: replace all \r\n and \r with \n before storing.

- `get_inbox_page(pool, user_id, page, page_size) -> Result<Vec<Message>, sqlx::Error>`: SELECT WHERE recipient_id = ? ORDER BY sent_at DESC LIMIT ? OFFSET ?. Do NOT include body in this query (SELECT id, sender_id, recipient_id, subject, '', sent_at, is_read) to save memory on list views. Use a separate struct `InboxMessage` (without body) or just use Message with empty body string.

  Actually, simpler approach: create an `InboxEntry` struct with id, sender_id, subject, sent_at, is_read (no body, no recipient_id since we know it). Query with those columns only.

- `get_inbox_count(pool, user_id) -> Result<i64, sqlx::Error>`: SELECT COUNT(*) WHERE recipient_id = ?

- `get_unread_count(pool, user_id) -> Result<i64, sqlx::Error>`: SELECT COUNT(*) WHERE recipient_id = ? AND is_read = 0

- `get_message_by_id(pool, message_id, user_id) -> Result<Option<Message>, sqlx::Error>`: SELECT * WHERE id = ? AND recipient_id = ?. Ownership check built into query.

- `mark_message_read(pool, message_id, user_id) -> Result<(), sqlx::Error>`: UPDATE SET is_read = 1 WHERE id = ? AND recipient_id = ?

- `delete_message(pool, message_id, user_id) -> Result<bool, sqlx::Error>`: DELETE WHERE id = ? AND recipient_id = ?. Return true if rows_affected > 0.

- `get_sender_handles(pool, sender_ids: &[i64]) -> Result<Vec<(i64, String)>, sqlx::Error>`: For a list of sender IDs, return (id, handle) pairs. Use a loop with individual queries since sqlx doesn't support IN clauses with slices easily. Deduplicate sender_ids before querying.

- `check_mailbox_full(pool, recipient_id, limit) -> Result<bool, sqlx::Error>`: SELECT COUNT(*) WHERE recipient_id = ? and compare against limit. Return true if count >= limit.

3. Register module in db/mod.rs: add `pub mod messages;`

IMPORTANT: Use string-based sqlx queries (not compile-time macros) to match Phase 2 decision. All datetime values use datetime('now', '-5 hours') for EST timezone consistency.
  </action>
  <verify>
Run `cargo check` from backend directory to verify compilation. Run `cargo test` to verify existing tests still pass.
  </verify>
  <done>
messages.rs compiles with all CRUD functions. Module registered in db/mod.rs. Schema includes messages table with foreign keys and indexes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Mail configuration section</name>
  <files>
    backend/src/config.rs
    config.toml
  </files>
  <action>
1. Add MailConfig struct to config.rs (near the other config structs):

```rust
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct MailConfig {
    #[serde(default = "default_mailbox_size_limit")]
    pub mailbox_size_limit: i64,
}

fn default_mailbox_size_limit() -> i64 {
    100
}

impl Default for MailConfig {
    fn default() -> Self {
        Self {
            mailbox_size_limit: default_mailbox_size_limit(),
        }
    }
}
```

NOTE: The existing Config struct has an `email` field for SMTP config. The mail config is DIFFERENT - it's for BBS mail system settings. Name it `mail` in the Config struct to avoid confusion with the SMTP `email` field.

2. Add to Config struct:
```rust
#[serde(default)]
pub mail: MailConfig,
```

3. Add `[mail]` section to config.toml:
```toml
[mail]
mailbox_size_limit = 100
```

Place it after the [time_limits] section and before menu sections.
  </action>
  <verify>
Run `cargo check` to verify config deserialization compiles. Run `cargo test` to ensure existing config tests pass. Verify the BBS starts with `cargo run` and loads the new config section without error.
  </verify>
  <done>
MailConfig struct exists with mailbox_size_limit defaulting to 100. Config.toml has [mail] section. BBS loads config without error.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes in backend directory
2. `cargo test` passes with no regressions
3. Schema includes messages table with correct columns and foreign keys
4. db/messages.rs exports all required CRUD functions
5. config.rs includes MailConfig with serde defaults
6. config.toml has [mail] section
</verification>

<success_criteria>
- Messages table DDL in schema.sql with CASCADE foreign keys
- All 8+ CRUD functions in db/messages.rs compile successfully
- MailConfig with mailbox_size_limit in config.rs
- config.toml updated with [mail] section
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/05-email-system/05-01-SUMMARY.md`
</output>
