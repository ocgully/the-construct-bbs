---
phase: 01-terminal-foundation
plan: 04
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - backend/src/websocket/mod.rs
  - backend/src/websocket/session.rs
  - backend/src/websocket/protocol.rs
  - backend/src/main.rs
autonomous: true

must_haves:
  truths:
    - "Browser can establish WebSocket connection to backend on /ws endpoint"
    - "Server sends ANSI-formatted welcome output to newly connected client"
    - "User input typed in browser terminal is received by backend session"
    - "Session can route user to a service from the registry and handle service I/O"
    - "ANSI escape sequences are buffered to prevent partial sequence rendering"
    - "Multiple simultaneous WebSocket connections are handled independently"
  artifacts:
    - path: "backend/src/websocket/mod.rs"
      provides: "WebSocket upgrade handler for axum"
      contains: "ws_handler"
    - path: "backend/src/websocket/session.rs"
      provides: "Per-connection session state with service routing and SessionIO implementation"
      contains: "Session"
    - path: "backend/src/websocket/protocol.rs"
      provides: "ANSI escape sequence buffering for WebSocket frames"
      contains: "AnsiBuffer"
  key_links:
    - from: "backend/src/main.rs"
      to: "backend/src/websocket/mod.rs"
      via: "axum Router route /ws mapped to ws_handler"
      pattern: "route.*ws.*ws_handler"
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/services/registry.rs"
      via: "Session accesses ServiceRegistry to enter services"
      pattern: "ServiceRegistry"
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/terminal/ansi.rs"
      via: "Session uses AnsiWriter to compose output"
      pattern: "AnsiWriter"
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/services/mod.rs"
      via: "Session implements SessionIO trait for service output"
      pattern: "SessionIO"
---

<objective>
Build the WebSocket layer that connects browser terminals to the backend -- WebSocket upgrade handler, per-connection session management, ANSI sequence buffering, and service routing.

Purpose: This is the communication bridge. Every keystroke from the browser flows through the WebSocket to a Session, which routes it to the active service. Every ANSI art frame, menu, and game output flows back through the Session to the WebSocket to the browser. Without this, the terminal is just a pretty shell with nothing behind it.

Output: Working WebSocket endpoint at /ws that accepts connections, creates sessions, sends welcome output, and can route users to services from the registry.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-terminal-foundation/01-RESEARCH.md
@.planning/phases/01-terminal-foundation/01-CONTEXT.md

@.planning/phases/01-terminal-foundation/01-01-SUMMARY.md
@.planning/phases/01-terminal-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket handler and ANSI buffering protocol</name>
  <files>
    backend/src/websocket/mod.rs
    backend/src/websocket/protocol.rs
    backend/src/main.rs
  </files>
  <action>
1. Create `backend/src/websocket/mod.rs`:
   - `pub mod session;`
   - `pub mod protocol;`
   - Export the WebSocket handler function

   - `pub async fn ws_handler(ws: WebSocketUpgrade, State(state): State<Arc<AppState>>) -> Response`:
     - Accept the WebSocket upgrade
     - Call `ws.on_upgrade(move |socket| handle_socket(socket, state))`
   - `async fn handle_socket(socket: WebSocket, state: Arc<AppState>)`:
     - Split socket into sender and receiver using `socket.split()`
     - Create a tokio mpsc channel for outbound messages (session writes to channel, sender task reads from channel)
     - Spawn sender task: reads from mpsc receiver, sends to WebSocket sender
     - Create Session with the mpsc sender and reference to AppState
     - Call session.on_connect() to send welcome screen
     - Loop: receive messages from WebSocket receiver
       - On Text message: pass to session.handle_input()
       - On Close: break loop, call session.on_disconnect()
       - On Binary: ignore (or log warning)
     - Clean up: drop session, close channel

2. Create `backend/src/websocket/protocol.rs`:
   - `pub struct AnsiBuffer`:
     - `buffer: Vec<u8>` -- accumulates incoming bytes
     - `in_escape: bool` -- tracking escape sequence state
   - `AnsiBuffer::new() -> Self`
   - `AnsiBuffer::push(&mut self, data: &[u8]) -> Vec<String>`:
     - Process bytes, track ESC sequence state
     - Return complete sequences/text chunks ready to send to terminal
     - Buffer incomplete escape sequences until terminator received
     - ESC sequence starts with 0x1B, ends with alphabetic character (A-Z, a-z)
     - CSI sequences: ESC [ ... letter (parameters between [ and letter)
   - `AnsiBuffer::flush(&mut self) -> Option<String>`:
     - Force-flush any remaining buffered content (use on disconnect)

   Note: This buffer is for SERVER-SIDE output buffering before sending to the client. It ensures we never send a partial ANSI sequence over WebSocket. The client (xterm.js) will receive complete sequences.

3. Add WebSocket route to `backend/src/main.rs`:
   - Add `mod websocket;` module declaration
   - Add route: `.route("/ws", get(websocket::ws_handler))`
   - Ensure AppState is passed via axum's State extractor
   - Keep existing /health route

4. Write unit tests for AnsiBuffer:
   - Test that complete text passes through immediately
   - Test that partial ESC sequence is buffered
   - Test that ESC[31m (set red) is held until 'm' received, then flushed as complete sequence
   - Test that multiple sequences in one push are all returned
  </action>
  <verify>
Run `cd backend && cargo build` -- compiles with WebSocket handler.
Run `cd backend && cargo test` -- AnsiBuffer tests pass.
Run backend server and use a WebSocket client tool (e.g., `websocat ws://127.0.0.1:3000/ws`) to verify connection is accepted.
  </verify>
  <done>
WebSocket endpoint at /ws accepts connections. ANSI buffer prevents partial escape sequences from being sent. Handler creates session per connection with proper channel-based output flow.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Session with service routing and welcome screen</name>
  <files>
    backend/src/websocket/session.rs
  </files>
  <action>
1. Create `backend/src/websocket/session.rs`:

   **Session struct:**
   - `tx: mpsc::Sender<String>` -- channel to send output to WebSocket sender task
   - `state: Arc<AppState>` -- shared application state (config, registry)
   - `current_service: Option<String>` -- name of currently active service (None = main prompt)
   - `output_buffer: AnsiWriter` -- for composing ANSI output

   **SessionIO implementation for Session:**
   - Implement the `SessionIO` trait (defined in services/mod.rs) for Session:
     - `write(&mut self, data: &str)` -- appends to output buffer, flushes via tx channel
     - `writeln(&mut self, data: &str)` -- appends data + "\r\n", flushes via tx channel
   - The flush sends the buffered string through the mpsc channel to the WebSocket sender task

   **Session methods:**
   - `new(tx: mpsc::Sender<String>, state: Arc<AppState>) -> Self`

   - `async fn on_connect(&mut self)`:
     - Use AnsiWriter to compose welcome screen:
       1. Begin synchronized rendering (DECSET 2026)
       2. Clear screen
       3. Write a simple welcome banner in CGA colors:
          - Bright cyan: "The Construct BBS"
          - Light gray: "Terminal Foundation v0.1"
          - Empty line
          - Show available services from registry: list each with number
          - Show prompt: "Enter service number or 'quit' to disconnect: "
       4. End synchronized rendering
     - Send the composed output via tx channel

   - `async fn handle_input(&mut self, input: &str)`:
     - If currently in a service:
       - Get the service from registry
       - Call service.handle_input(self, input)
       - If result is ServiceAction::Exit: call service.on_exit(self), set current_service to None, show welcome/menu again
     - If not in a service (at main prompt):
       - Parse input as service selection (number or name)
       - If valid service found: set current_service, show "Entering {service}..." delay message, call service.on_enter(self)
       - If "quit" or "q": send goodbye message, signal disconnect
       - If invalid: send "Unknown command" and re-show prompt

   - `async fn on_disconnect(&mut self)`:
     - If in a service: call service.on_exit()
     - Log disconnection

   **"Entering door..." delay:**
   - When entering a service, write "Entering {service_name}..." in bright yellow
   - Use `tokio::time::sleep(Duration::from_millis(800))` for the authentic BBS loading feel
   - Then clear screen and call service.on_enter()
   - This matches the CONTEXT.md requirement for BBS-style loading delay

2. Ensure Session properly handles the output flow:
   - Session composes ANSI output using AnsiWriter
   - Flushes completed output through mpsc channel
   - WebSocket sender task (in mod.rs) picks up from channel and sends as Text frame
  </action>
  <verify>
Run `cd backend && cargo build` -- compiles with session module.
Start the server. Connect with `websocat ws://127.0.0.1:3000/ws`:
  - Should see welcome banner with ANSI color codes
  - Should see "example" service listed (if enabled in config)
  - Type the service number -- should see "Entering example..." then example service output
  - Type "quit" in example service -- should return to main prompt
  - Type "quit" at main prompt -- connection should close
Test two simultaneous websocat connections -- both should work independently.
  </verify>
  <done>
Session manages per-connection state. Welcome screen renders with ANSI colors. User can enter services from registry and exit back to main prompt. "Entering door..." delay provides authentic BBS feel. Multiple simultaneous sessions work independently.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds with websocket module
2. `cargo test` passes AnsiBuffer tests
3. WebSocket connection at ws://127.0.0.1:3000/ws is accepted
4. Welcome banner displays with ANSI color codes
5. Service listing shows enabled services from config
6. User can enter example service and interact with it
7. User can exit service and return to main prompt
8. "Entering door..." delay occurs when entering service
9. Two simultaneous connections work independently
10. Disconnection is handled cleanly (no panics, resources freed)
</verification>

<success_criteria>
- WebSocket endpoint accepts browser connections and creates isolated sessions
- Sessions display ANSI-colored welcome screen with service listing
- Service routing works: enter service by number, exit with service-specific command
- ANSI sequences are properly buffered (no partial sequences sent)
- Multiple concurrent sessions work without interference
- Foundation is ready for Plan 05 integration with frontend
</success_criteria>

<output>
After completion, create `.planning/phases/01-terminal-foundation/01-04-SUMMARY.md`
</output>
