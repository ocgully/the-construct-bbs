---
phase: 01-terminal-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/Cargo.toml
  - backend/src/main.rs
  - backend/src/config.rs
  - backend/src/services/mod.rs
  - backend/src/services/registry.rs
  - backend/src/services/example.rs
  - config.toml
autonomous: true

must_haves:
  truths:
    - "Rust backend compiles and starts an axum HTTP server on a configurable port"
    - "Service registry loads enabled services from TOML config at startup"
    - "Services can be enabled/disabled by changing config.toml without code changes"
    - "New services can be added by implementing the Service trait and registering in the factory"
  artifacts:
    - path: "backend/Cargo.toml"
      provides: "Rust project with axum, tokio, serde, toml, codepage-437 dependencies"
      contains: "axum"
    - path: "backend/src/main.rs"
      provides: "Axum server entry point with shared state"
      contains: "tokio::main"
    - path: "backend/src/config.rs"
      provides: "TOML config loading with serde deserialization"
      contains: "ServiceConfig"
    - path: "backend/src/services/mod.rs"
      provides: "Service trait definition"
      contains: "trait Service"
    - path: "backend/src/services/registry.rs"
      provides: "Config-driven service registry with Arc<dyn Service>"
      contains: "ServiceRegistry"
    - path: "config.toml"
      provides: "Default BBS configuration with example service entries"
      contains: "[[services]]"
  key_links:
    - from: "backend/src/main.rs"
      to: "backend/src/config.rs"
      via: "Config::load() call at startup"
      pattern: "Config::load"
    - from: "backend/src/services/registry.rs"
      to: "backend/src/config.rs"
      via: "ServiceRegistry::from_config reads ServiceConfig entries"
      pattern: "from_config"
    - from: "backend/src/services/registry.rs"
      to: "backend/src/services/mod.rs"
      via: "Registry stores Arc<dyn Service> trait objects"
      pattern: "Arc<dyn Service>"
---

<objective>
Set up the Rust backend project with axum web server, TOML configuration loading, and the pluggable service architecture (Service trait + config-driven registry).

Purpose: This is the foundation everything else builds on -- the server that will handle WebSocket connections, the config system that controls which services are active, and the plugin architecture that all BBS features (email, chat, games) will implement.

Output: Compilable Rust project with running axum server, config loader, Service trait, and ServiceRegistry that loads enabled services from config.toml.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-terminal-foundation/01-RESEARCH.md
@.planning/phases/01-terminal-foundation/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Rust project with axum server and config system</name>
  <files>
    backend/Cargo.toml
    backend/src/main.rs
    backend/src/config.rs
    config.toml
  </files>
  <action>
Create a new Rust project in `backend/` directory:

1. Run `cargo init backend` to create the project.

2. Add dependencies to Cargo.toml:
   - axum 0.7 with "ws" feature (web framework + WebSocket support)
   - tokio 1 with "full" feature (async runtime)
   - serde 1 with "derive" feature (serialization)
   - toml 0.8 (config file parsing)
   - codepage-437 0.1 (CP437 encoding conversion)
   - tower-http 0.6 with "fs" and "cors" features (static file serving, will be used in Plan 05)

3. Create `config.toml` at the project root (not inside backend/) with this structure:
   ```toml
   [server]
   host = "127.0.0.1"
   port = 3000

   [terminal]
   cols = 80
   rows = 24

   [[services]]
   name = "example"
   enabled = true
   description = "Example service for testing"
   ```

4. Create `backend/src/config.rs`:
   - Define `Config` struct with `server: ServerConfig`, `terminal: TerminalConfig`, `services: Vec<ServiceConfig>`
   - `ServerConfig` has `host: String`, `port: u16`
   - `TerminalConfig` has `cols: u16`, `rows: u16`
   - `ServiceConfig` has `name: String`, `enabled: bool`, `description: String`
   - All structs derive `Debug, Deserialize, Serialize`
   - Implement `Config::load(path: &str) -> Result<Self, Box<dyn std::error::Error>>` that reads and parses TOML file
   - Default config path should be "config.toml"

5. Create `backend/src/main.rs`:
   - Load config from `config.toml` (look in current directory, then parent directory -- since server runs from backend/ but config is at project root)
   - Create axum Router with a health check GET route at `/health` returning "OK"
   - Bind to configured host:port
   - Print startup message: "The Construct BBS listening on {host}:{port}"
   - Use `Arc<AppState>` as shared state containing `config: Config` and `registry: ServiceRegistry` (ServiceRegistry created in Task 2)
   - Add `mod config;` and `mod services;` module declarations

Do NOT add WebSocket routes yet -- that's Plan 04.
  </action>
  <verify>
Run `cd backend && cargo build` -- should compile without errors.
Run `cargo run` from backend/ directory -- should print startup message and respond to `curl http://127.0.0.1:3000/health` with "OK".
  </verify>
  <done>
Rust project compiles, axum server starts on configured port, health endpoint responds, config loads from TOML file.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Service trait and config-driven registry</name>
  <files>
    backend/src/services/mod.rs
    backend/src/services/registry.rs
    backend/src/services/example.rs
  </files>
  <action>
1. Create `backend/src/services/mod.rs`:
   - Define the `Service` trait (must be `Send + Sync` for Arc usage):
     ```rust
     pub trait Service: Send + Sync {
         fn name(&self) -> &str;
         fn description(&self) -> &str;
         // Called when user enters this service
         fn on_enter(&self, session: &mut dyn SessionIO) -> Result<(), ServiceError>;
         // Called with each line of user input while in this service
         fn handle_input(&self, session: &mut dyn SessionIO, input: &str) -> Result<ServiceAction, ServiceError>;
         // Called when user exits this service
         fn on_exit(&self, session: &mut dyn SessionIO);
     }
     ```
   - Define `ServiceAction` enum: `Continue`, `Exit` (service tells the session what to do next)
   - Define `ServiceError` type (use `thiserror` or simple enum with Display impl)
   - Define `SessionIO` trait for session abstraction (services write output and read input through this):
     ```rust
     pub trait SessionIO {
         fn write(&mut self, data: &str);
         fn writeln(&mut self, data: &str);
     }
     ```
     Note: SessionIO is intentionally minimal now. It will be expanded in Plan 04 when WebSocket sessions are implemented. Services write through this abstraction so they don't depend on WebSocket directly.
   - Re-export `Service`, `ServiceAction`, `ServiceError`, `SessionIO`, and `ServiceRegistry`

2. Create `backend/src/services/registry.rs`:
   - `ServiceRegistry` struct with `services: HashMap<String, Arc<dyn Service>>`
   - `ServiceRegistry::from_config(config: &Config) -> Self`:
     - Iterate config.services
     - For each enabled service, call a factory function to create the concrete type
     - Use a match on service name to map to concrete types (e.g., "example" -> ExampleService)
     - Log which services are loaded and which are skipped (disabled)
   - `ServiceRegistry::get(&self, name: &str) -> Option<&Arc<dyn Service>>`
   - `ServiceRegistry::list(&self) -> Vec<(&str, &str)>` -- returns (name, description) pairs for menu display
   - `ServiceRegistry::is_empty(&self) -> bool`

3. Create `backend/src/services/example.rs`:
   - `ExampleService` struct implementing `Service` trait
   - on_enter: writes "Welcome to the Example Service!" and "Type 'quit' to exit."
   - handle_input: echoes input back, returns `ServiceAction::Exit` on "quit" or "q"
   - on_exit: writes "Leaving Example Service..."
   - This validates the entire plugin architecture works end-to-end

4. Wire into main.rs:
   - Create `ServiceRegistry::from_config(&config)` during startup
   - Log number of services loaded: "Loaded {n} service(s)"
   - Store registry in AppState

Add `thiserror` to Cargo.toml dependencies for ServiceError derive macros.
  </action>
  <verify>
Run `cd backend && cargo build` -- compiles without errors.
Run `cargo test` -- if any unit tests added, they pass.
Modify config.toml to set example service `enabled = false`, restart server -- startup log should show 0 services loaded.
Set it back to `enabled = true` -- startup log should show 1 service loaded.
  </verify>
  <done>
Service trait defined with SessionIO abstraction. ServiceRegistry loads enabled services from config. ExampleService validates the plugin pattern. Toggling `enabled` in config.toml controls service loading without code changes.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds in backend/ directory
2. `cargo run` starts server, prints startup message with configured host:port
3. `curl http://127.0.0.1:3000/health` returns "OK"
4. Config loads from config.toml -- changing port in config changes server bind address
5. ServiceRegistry loads example service when enabled, skips when disabled
6. Service trait, SessionIO trait, and ServiceAction enum are properly defined for downstream use
</verification>

<success_criteria>
- Rust project compiles with all required dependencies
- Axum server starts and serves health endpoint
- TOML config system works with server, terminal, and services sections
- Service trait defines the plugin interface all future services will implement
- ServiceRegistry dynamically loads/skips services based on config
- ExampleService proves the pattern works end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/01-terminal-foundation/01-01-SUMMARY.md`
</output>
