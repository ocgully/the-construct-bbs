---
phase: 01-terminal-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/terminal/mod.rs
  - backend/src/terminal/ansi.rs
  - backend/src/terminal/paging.rs
autonomous: true

must_haves:
  truths:
    - "AnsiWriter can build complete ANSI escape sequences for colors, cursor movement, and screen clearing"
    - "CP437 byte arrays are correctly converted to UTF-8 strings preserving box-drawing characters"
    - "Paginated output pauses after N lines and waits for user input before continuing"
    - "Synchronized rendering wraps screen updates in DECSET 2026 begin/end sequences"
  artifacts:
    - path: "backend/src/terminal/mod.rs"
      provides: "Terminal module re-exports"
      contains: "mod ansi"
    - path: "backend/src/terminal/ansi.rs"
      provides: "AnsiWriter with CGA colors, cursor control, CP437 conversion, synchronized rendering"
      contains: "AnsiWriter"
    - path: "backend/src/terminal/paging.rs"
      provides: "[More] prompt paging for long output"
      contains: "Pager"
  key_links:
    - from: "backend/src/terminal/ansi.rs"
      to: "codepage-437 crate"
      via: "FromCp437 trait for CP437->UTF-8 conversion"
      pattern: "from_cp437"
    - from: "backend/src/terminal/ansi.rs"
      to: "ANSI escape sequences"
      via: "ESC[ sequences for color, cursor, screen control"
      pattern: "\\\\x1B\\["
---

<objective>
Build the terminal output engine -- AnsiWriter for composing ANSI escape sequences with CGA colors and synchronized rendering, CP437-to-UTF-8 conversion for authentic character rendering, and a [More] pager for paginated output.

Purpose: Every screen in the BBS (menus, ANSI art, game output, chat) flows through this terminal engine. It must produce correct ANSI sequences, convert CP437 box-drawing characters to valid UTF-8, and paginate long output with [More] prompts -- all foundational to the authentic BBS experience.

Output: Terminal module with AnsiWriter, CP437 conversion utilities, and Pager -- ready for WebSocket sessions to use in Plan 04.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-terminal-foundation/01-RESEARCH.md
@.planning/phases/01-terminal-foundation/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AnsiWriter with CGA palette and CP437 conversion</name>
  <files>
    backend/src/terminal/mod.rs
    backend/src/terminal/ansi.rs
  </files>
  <action>
Create the terminal output module. Note: this plan creates files inside backend/src/ but does NOT modify main.rs (Plan 01 owns main.rs and will add `mod terminal;`). If Plan 01 has not run yet, add the `mod terminal;` declaration to main.rs here so the module compiles.

1. Create `backend/src/terminal/mod.rs`:
   - `pub mod ansi;`
   - `pub mod paging;`
   - Re-export key types: `AnsiWriter`, `Color`, `Pager`

2. Create `backend/src/terminal/ansi.rs`:

   **CGA Color enum:**
   - Define `Color` enum with all 16 CGA colors: Black, Red, Green, Brown, Blue, Magenta, Cyan, LightGray, DarkGray, LightRed, LightGreen, Yellow, LightBlue, LightMagenta, LightCyan, White
   - Implement methods: `fg_code(&self) -> u8` (30-37 for normal, 90-97 for bright), `bg_code(&self) -> u8` (40-47 for normal, 100-107 for bright)
   - Note: Brown (not "dark yellow") is CGA color 6, Yellow is bright color 14

   **AnsiWriter struct:**
   - Internal `buffer: String` for composing output
   - `new() -> Self` -- creates empty writer
   - `begin_sync(&mut self)` -- writes `\x1B[?2026h` (DECSET 2026 synchronized rendering begin)
   - `end_sync(&mut self)` -- writes `\x1B[?2026l` (DECSET 2026 synchronized rendering end)
   - `clear_screen(&mut self)` -- writes `\x1B[2J\x1B[H` (clear screen + home cursor)
   - `move_cursor(&mut self, row: u16, col: u16)` -- writes `\x1B[{row};{col}H` (1-based)
   - `set_color(&mut self, fg: Color, bg: Color)` -- writes `\x1B[{fg};{bg}m`
   - `set_fg(&mut self, fg: Color)` -- writes `\x1B[{fg}m`
   - `set_bg(&mut self, bg: Color)` -- writes `\x1B[{bg}m`
   - `reset_color(&mut self)` -- writes `\x1B[0m`
   - `bold(&mut self)` -- writes `\x1B[1m`
   - `write_str(&mut self, text: &str)` -- appends raw text
   - `writeln(&mut self, text: &str)` -- appends text + `\r\n`
   - `write_cp437(&mut self, bytes: &[u8])` -- converts CP437 bytes to UTF-8 using `codepage_437::FromCp437` trait with `CP437_CONTROL` mapping, appends result
   - `hide_cursor(&mut self)` -- writes `\x1B[?25l`
   - `show_cursor(&mut self)` -- writes `\x1B[?25h`
   - `flush(&mut self) -> String` -- takes and returns buffer contents (using `std::mem::take`)
   - `len(&self) -> usize` -- returns current buffer length
   - `is_empty(&self) -> bool`

   **Helper function:**
   - `pub fn cp437_to_utf8(bytes: &[u8]) -> String` -- standalone conversion function using codepage-437 crate. Use `bytes.iter().copied().from_cp437(&CP437_CONTROL).collect::<String>()`

   **Important:** Use `\r\n` for line endings (not just `\n`) since BBS terminals expect carriage return + line feed.

3. Add `mod terminal;` to main.rs if it doesn't already exist (coordinate with Plan 01 -- if both run in Wave 1, either plan may need to add it).

4. Write unit tests in the same file (or a tests submodule):
   - Test that `cp437_to_utf8` correctly converts box-drawing bytes (0xB3 -> U+2502 "│", 0xC4 -> U+2500 "─", 0xDA -> U+250C "┌")
   - Test that AnsiWriter produces correct escape sequences for color setting
   - Test that clear_screen produces `\x1B[2J\x1B[H`
   - Test that synchronized rendering wraps content in DECSET 2026
   - Test that flush returns buffer and leaves writer empty
  </action>
  <verify>
Run `cd backend && cargo build` -- compiles (may need to temporarily add `mod terminal;` to main.rs or create a lib.rs).
Run `cd backend && cargo test` -- all unit tests pass.
Verify CP437 box-drawing conversion produces correct UTF-8 codepoints.
  </verify>
  <done>
AnsiWriter produces valid ANSI escape sequences. CP437 bytes convert to correct UTF-8. CGA 16-color palette is accurately represented. Synchronized rendering brackets work. All unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement [More] prompt pager for paginated output</name>
  <files>
    backend/src/terminal/paging.rs
  </files>
  <action>
Create the paging system that breaks long output into terminal-sized pages with [More] prompts. This is critical for authenticity -- real BBSes never had infinite scrolling.

1. Create `backend/src/terminal/paging.rs`:

   **Pager struct:**
   - `terminal_rows: u16` -- number of rows in terminal (from config, typically 24)
   - `reserved_rows: u16` -- rows reserved for status line and prompt (typically 2: line 24 for status, line 23 for [More] prompt)
   - `lines_shown: u16` -- counter of lines displayed since last pause
   - `page_size() -> u16` -- returns `terminal_rows - reserved_rows` (usable lines per page)

   **Pager methods:**
   - `new(terminal_rows: u16) -> Self` -- creates pager with 2 reserved rows
   - `reset(&mut self)` -- resets lines_shown to 0
   - `paginate(&mut self, text: &str) -> Vec<Page>` -- splits text into pages:
     - Split text by `\r\n` (or `\n`) into lines
     - Group lines into pages of `page_size()` lines each
     - Return Vec<Page> where each Page contains the lines for that page
     - Last page may have fewer lines (no padding needed)
   - `needs_pause(&self) -> bool` -- returns true if lines_shown >= page_size()
   - `add_lines(&mut self, count: u16)` -- increments lines_shown

   **Page struct:**
   - `lines: Vec<String>` -- the lines of text for this page
   - `is_last: bool` -- true if this is the final page (no [More] prompt needed)
   - `to_ansi(&self) -> String` -- renders lines joined with `\r\n`

   **More prompt rendering:**
   - `pub fn more_prompt() -> String` -- returns the [More] prompt ANSI string:
     - Position cursor at row 23 (or page_size + 1)
     - Set color to bright white on blue (or similar high-contrast BBS style)
     - Write `[More - Press any key to continue, Q to quit]`
     - Reset color
   - `pub fn clear_more_prompt(cols: u16) -> String` -- clears the [More] line by overwriting with spaces

2. Write unit tests:
   - Test paginate with text shorter than one page (returns single page, is_last = true)
   - Test paginate with text exactly one page (returns single page, is_last = true)
   - Test paginate with text spanning 2.5 pages (returns 3 pages, only last is_last = true)
   - Test page_size calculation (24 rows - 2 reserved = 22 lines per page)
   - Test empty input returns empty vec
   - Test more_prompt contains escape sequences and prompt text
  </action>
  <verify>
Run `cd backend && cargo test` -- all paging tests pass.
Verify that paginate correctly splits a 50-line text into 3 pages (22 + 22 + 6 lines) for a 24-row terminal.
  </verify>
  <done>
Pager splits long output into terminal-sized pages. [More] prompt renders with correct ANSI styling. Page struct carries metadata about whether more pages follow. All unit tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds with terminal module
2. `cargo test` passes all unit tests for AnsiWriter, CP437 conversion, and Pager
3. CP437 box-drawing characters (0xB3, 0xC4, 0xDA, 0xBF, 0xD9, 0xC0) all convert to correct UTF-8
4. CGA 16-color codes are correct (Color::Brown produces code 33, not "dark yellow")
5. Pager correctly splits 50 lines into 3 pages for 24-row terminal
6. [More] prompt contains proper ANSI escape sequences
7. Synchronized rendering brackets (DECSET 2026) are correctly generated
</verification>

<success_criteria>
- AnsiWriter produces valid, complete ANSI escape sequences for all BBS output needs
- CP437-to-UTF-8 conversion handles all 256 codepoints including box-drawing characters
- Pager enforces paginated output with configurable terminal dimensions
- All functionality has unit tests proving correctness
- Module is ready for Plan 04 to wire into WebSocket sessions
</success_criteria>

<output>
After completion, create `.planning/phases/01-terminal-foundation/01-02-SUMMARY.md`
</output>
