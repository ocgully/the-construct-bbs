---
phase: 02-authentication-connection
plan: 07
type: execute
wave: 6
depends_on: ["02-03", "02-04", "02-05", "02-06"]
files_modified:
  - backend/src/websocket/session.rs
  - backend/src/websocket/mod.rs
  - backend/src/connection/ceremony.rs
  - backend/src/services/welcome_art.rs
  - backend/src/main.rs
  - frontend/src/websocket.ts
  - frontend/src/main.ts
autonomous: false

must_haves:
  truths:
    - "Complete flow works end-to-end: connect -> ceremony -> login/register -> main menu -> quit -> goodbye"
    - "New user can register, verify email, log in, see profile, quit with goodbye"
    - "Returning user reconnects with stored token and skips ceremony/login"
    - "Line busy rejection works when max_nodes reached"
    - "Node counts are accurate throughout the session lifecycle"
    - "All Phase 2 success criteria verified"
  artifacts:
    - path: "backend/src/websocket/session.rs"
      provides: "Fully integrated session with ceremony -> auth -> service flow"
    - path: "backend/src/main.rs"
      provides: "Server startup with DB, node manager, config all wired"
  key_links:
    - from: "frontend/src/main.ts"
      to: "frontend/src/websocket.ts"
      via: "Connect prompt -> audio -> WebSocket -> auth token"
      pattern: "connectWebSocket"
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/connection/ceremony.rs"
      via: "on_connect runs ceremony first"
      pattern: "run_connection_ceremony"
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/services/login.rs"
      via: "After ceremony, login flow starts"
      pattern: "LoginFlow"
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/services/goodbye.rs"
      via: "Quit triggers goodbye sequence"
      pattern: "render_goodbye"
---

<objective>
Integrate all Phase 2 components into a complete, working end-to-end flow and verify all success criteria are met.

Purpose: Plans 01-06 built individual components (DB, auth, ceremony, registration, login, profile, goodbye). This plan wires them together into the complete connection-to-disconnection lifecycle and verifies everything works as a cohesive experience.

Output: Fully working Phase 2: user connects, hears modem sound, sees ceremony, logs in or registers, sees main menu, can view profile, quits with goodbye screen, and can resume session on reconnect.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-authentication-connection/02-CONTEXT.md

@backend/src/main.rs
@backend/src/websocket/session.rs
@backend/src/websocket/mod.rs
@backend/src/connection/ceremony.rs
@backend/src/services/mod.rs
@backend/src/config.rs
@frontend/src/main.ts
@frontend/src/websocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire complete session lifecycle and fix integration issues</name>
  <files>
    backend/src/websocket/session.rs
    backend/src/websocket/mod.rs
    backend/src/connection/ceremony.rs
    backend/src/services/welcome_art.rs
    backend/src/main.rs
    frontend/src/websocket.ts
    frontend/src/main.ts
  </files>
  <action>
This task is PURE INTEGRATION WIRING. Do NOT implement new features, business logic, or new modules. The goal is to connect existing components from Plans 01-06 and fix any compilation or integration gaps between them. If a component is missing or incomplete, add only the minimal glue code to connect it -- do not build new functionality.

**Review and fix the complete session lifecycle:**

1. **Frontend connect flow** (main.ts + websocket.ts):
   - Verify: Page loads -> "Press ENTER to connect..." prompt shown
   - Verify: User presses key -> modem sound plays -> WebSocket connects
   - Verify: On ws.open -> terminal clears -> sends auth JSON with token from localStorage
   - Verify: Incoming JSON messages (session, logout types) are intercepted and NOT written to terminal
   - Verify: All other incoming messages written to terminal as ANSI text
   - FIX any missing imports, broken references, or mismatched message formats between frontend and backend

2. **Backend first-message handling** (session.rs):
   - Session starts in AwaitingAuth state
   - First message received should be the auth JSON from frontend
   - Parse JSON: if valid token, validate_session() -> if valid, authenticate directly (skip ceremony), show welcome-back and main menu
   - If no token or invalid token: run connection ceremony, then show login screen
   - EDGE CASE: If frontend sends a non-JSON first message (e.g., old client), treat as no auth and proceed to ceremony
   - FIX any type mismatches or missing function calls between session.rs and auth modules

3. **Connection ceremony flow** (ceremony.rs + session.rs):
   - Check node availability FIRST (before ceremony text)
   - If nodes full: send line busy, wait, then close connection
   - If nodes available: assign temporary node (handle = "connecting")
   - Send ceremony text with delays
   - Send splash screen
   - Transition to login state with login header
   - FIX any issues with ceremony -> login state transition

4. **Login/Registration flow** (session.rs):
   - After ceremony, show login header + "Enter your handle: " prompt
   - Character echo: each keypress echoed back (or * for password)
   - On Enter: process accumulated input through LoginFlow
   - "new" -> switch to RegistrationFlow
   - Successful login -> Authenticated state -> update node with real handle -> send session token JSON -> show welcome-back -> show main menu
   - Successful registration -> switch to LoginFlow for first login
   - FIX any broken connections between session and LoginFlow/RegistrationFlow

5. **Authenticated state** (session.rs):
   - All existing service routing works (enter service by number/name, quit to disconnect)
   - "quit"/"q" triggers goodbye sequence (not just simple disconnect)
   - Add profile command routing: when user types "profile" or "p" at main menu, call the profile rendering function from Plan 06
   - Node tracking: node info stays current until disconnect
   - NOTE: Profile rendering and goodbye were built in Plan 06. This step only WIRES them into the main menu routing.

6. **Disconnect handling** (session.rs + mod.rs):
   - Clean quit: goodbye screen -> save time -> delete session -> release node -> close WS
   - Browser close (unclean): save time -> release node (no goodbye screen)
   - Reconnect with token: validate -> restore state -> show welcome-back
   - FIX any missing cleanup calls or broken disconnect flow

7. **Main menu update** (welcome_art.rs):
   - After login, the main menu should show the user's handle and user level
   - Update welcome_art or create a new function that takes user info:
     ```
     ┌────────────────────────────────────────────────────────────────────┐
     │  THE CONSTRUCT BBS                     Node 3 of 16              │
     │  Logged in as: DarkAngel [Sysop]                                 │
     ├────────────────────────────────────────────────────────────────────┤
     │                                                                    │
     │  [1] Example Service     Test the BBS services                   │
     │  [P] Your Profile        View your user profile                  │
     │  [Q] Quit                Log off the BBS                         │
     │                                                                    │
     └────────────────────────────────────────────────────────────────────┘

     Enter selection:
     ```
   - Add Profile option (P) to main menu routing
   - Show node info and logged-in user in header

8. **Build and verify compilation:**
   - Run `cargo check` for backend
   - Run `npm run build` for frontend
   - Fix any compilation errors from integration
   - Run `cargo test` to verify no regressions

9. **Start the server and perform smoke test:**
   - Run `cargo run` from backend directory
   - Open browser to http://localhost:3000
   - Verify the frontend loads
   - Press Enter to connect
   - Verify connection ceremony appears
   - Verify login prompt appears after ceremony
  </action>
  <verify>
Run `cd C:/Git/bbs/backend && cargo check && cargo test` and `cd C:/Git/bbs/frontend && npm run build`. Both must pass.
Then start server with `cd C:/Git/bbs/backend && cargo run` and verify it starts without errors.
  </verify>
  <done>Complete session lifecycle compiles and starts. Frontend connect flow, backend ceremony, login, service routing, and disconnect all wired together. Profile accessible from main menu. No new features added -- only integration glue.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 2 authentication and connection system:
- Modem handshake audio on connect
- Connection ceremony with typewriter-paced text
- ANSI splash screen
- User registration with handle validation and profanity filter
- Login with password asterisks and lockout
- Session persistence across page refresh
- User profile ANSI card
- Goodbye screen with session stats
- Line busy rejection at max nodes
- Node tracking throughout session
  </what-built>
  <how-to-verify>
1. Start the backend: `cd C:/Git/bbs/backend && cargo run`
2. Build frontend: `cd C:/Git/bbs/frontend && npm run build`
3. Open browser to http://localhost:3000

**Test Connection Ceremony:**
4. Press Enter/any key to connect
5. Verify: modem sound plays (or degrades gracefully if no audio file)
6. Verify: connection text appears line-by-line with visible pacing
7. Verify: ANSI splash screen renders with colors
8. Verify: Login header shows with BBS name, tagline, node count

**Test Registration:**
9. Type "new" at handle prompt -> registration flow begins
10. Enter a handle -> validates (try too short, profane, then valid)
11. Enter email -> validates
12. Enter password -> verify asterisks shown, not plaintext
13. Confirm password -> verify mismatch rejected, match accepted
14. Verification code: check server console for code (no SMTP configured)
15. Enter code -> registration completes
16. Verify redirected to login

**Test Login:**
17. Enter the handle you just registered
18. Enter password (asterisks) -> verify welcome-back message
19. Verify main menu shown with handle and node info

**Test Profile:**
20. Type "p" or "profile" at main menu
21. Verify ANSI profile card displays with handle, join date, stats

**Test Session Persistence:**
22. Refresh the page (F5)
23. Press Enter to reconnect
24. Verify you are logged in automatically (no ceremony, no login prompt)
25. Verify main menu appears with your handle

**Test Goodbye:**
26. Type "q" or "quit" at main menu
27. Verify goodbye screen shows: session time, total calls, farewell message, NO CARRIER
28. Verify a few second pause before disconnect

**Test Line Busy (optional):**
29. Set max_nodes = 1 in config.toml, restart server
30. Connect in one browser tab
31. Try to connect in a second tab
32. Verify second tab sees "ALL LINES BUSY" message

Report any issues or approve with "approved".
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
All Phase 2 success criteria:
1. User hears modem handshake sound when connecting to BBS
2. User sees ANSI art splash screen during connection sequence
3. User can register new account with username and password
4. User can log in with existing credentials and session persists across page refresh
5. User receives "line busy" rejection when max concurrent users reached
6. User sees goodbye screen with session stats on logout
7. User profile displays name, join date, location, signature with tracked stats
</verification>

<success_criteria>
- End-to-end flow works: connect -> ceremony -> login/register -> main menu -> profile -> quit -> goodbye
- Modem audio plays (or gracefully degrades)
- Session token persists in localStorage, enables reconnect without re-login
- Registration validates all inputs, stores user in SQLite
- Login with password masking, lockout on failures
- Profile card shows all user data in ANSI art format
- Goodbye screen shows session stats with NO CARRIER
- Line busy rejects connections at max capacity
- All existing Phase 1 functionality still works (services, CRT effects, mobile)
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-connection/02-07-SUMMARY.md`
</output>
