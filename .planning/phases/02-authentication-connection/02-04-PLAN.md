---
phase: 02-authentication-connection
plan: 04
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - backend/Cargo.toml
  - backend/src/auth/email.rs
  - backend/src/auth/mod.rs
  - backend/src/db/verification.rs
  - backend/src/db/mod.rs
  - backend/src/services/registration.rs
  - backend/src/services/mod.rs
autonomous: true

must_haves:
  truths:
    - "User can register with handle, password, and email through terminal prompts"
    - "Handle is validated for length, characters, uniqueness, and profanity"
    - "Password is shown as asterisks during entry"
    - "Email verification code is generated and stored (email sending optional based on SMTP config)"
    - "User enters 6-digit verification code in terminal to complete registration"
    - "Duplicate handles and emails are rejected with clear messages"
  artifacts:
    - path: "backend/src/auth/email.rs"
      provides: "Email verification code generation and SMTP sending"
      exports: ["generate_verification_code", "send_verification_email"]
    - path: "backend/src/db/verification.rs"
      provides: "Verification code DB operations"
      exports: ["store_verification_code", "validate_verification_code"]
    - path: "backend/src/services/registration.rs"
      provides: "Interactive registration service with terminal prompts"
      exports: ["RegistrationService"]
  key_links:
    - from: "backend/src/services/registration.rs"
      to: "backend/src/auth/validation.rs"
      via: "validate_handle, validate_email, validate_password calls"
      pattern: "validate_handle|validate_email|validate_password"
    - from: "backend/src/services/registration.rs"
      to: "backend/src/auth/password.rs"
      via: "hash_password for registration"
      pattern: "hash_password"
    - from: "backend/src/services/registration.rs"
      to: "backend/src/db/user.rs"
      via: "create_user, handle_exists, email_exists"
      pattern: "create_user|handle_exists|email_exists"
---

<objective>
Implement user registration as an interactive terminal service: handle entry with validation, password with asterisk masking, email with verification code, and account creation.

Purpose: Registration is the gateway to the BBS. Users must be able to create accounts through the terminal interface before they can log in and use any features.

Output: Working registration flow that collects handle/password/email via terminal prompts, validates all inputs, creates the user in SQLite, generates email verification codes, and supports the 6-digit code entry flow.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-authentication-connection/02-CONTEXT.md
@.planning/phases/02-authentication-connection/02-RESEARCH.md

@backend/src/services/mod.rs
@backend/src/services/welcome_art.rs
@backend/src/websocket/session.rs
@backend/src/config.rs
@backend/src/db/user.rs
@backend/src/auth/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Email verification and verification code DB operations</name>
  <files>
    backend/Cargo.toml
    backend/src/auth/email.rs
    backend/src/auth/mod.rs
    backend/src/db/verification.rs
    backend/src/db/mod.rs
  </files>
  <action>
1. Add lettre to `backend/Cargo.toml`:
   ```toml
   lettre = { version = "0.11", default-features = false, features = ["tokio1", "tokio1-native-tls", "smtp-transport", "builder"] }
   ```

2. Create `backend/src/db/verification.rs`:
   - `pub async fn store_verification_code(pool: &SqlitePool, email: &str, code: &str, code_type: &str, expiry_hours: u32) -> Result<(), sqlx::Error>` -- DELETE any existing codes for this email+type first (only one active code per email per type), then INSERT new code with expires_at = datetime('now', '+N hours')
   - `pub async fn validate_verification_code(pool: &SqlitePool, email: &str, code: &str, code_type: &str) -> Result<bool, sqlx::Error>` -- SELECT from verification_codes WHERE email = ? AND code = ? AND code_type = ? AND used = 0 AND datetime(expires_at) > datetime('now'). If found, UPDATE used = 1, then UPDATE users SET email_verified = 1 WHERE email = ? (for registration type). Return true if found and valid, false otherwise.
   - `pub async fn cleanup_expired_codes(pool: &SqlitePool) -> Result<u64, sqlx::Error>` -- DELETE expired codes

3. Update `backend/src/db/mod.rs` to add `pub mod verification;`

4. Create `backend/src/auth/email.rs`:
   - `pub fn generate_verification_code() -> String` -- Use rand::thread_rng().gen_range(0..1000000) formatted as {:06} (zero-padded 6 digits)
   - `pub async fn send_verification_email(config: &Option<EmailConfig>, to_email: &str, code: &str, bbs_name: &str) -> Result<(), String>`:
     a. If config is None, log "SMTP not configured, verification code: {code}" to stdout and return Ok (development mode -- code visible in server logs)
     b. If config is Some, use lettre to build and send email:
        - From: config.from_name <config.from_address>
        - To: to_email
        - Subject: "{bbs_name} - Email Verification Code"
        - Body: "Your verification code is: {code}\n\nThis code expires in {expiry} hours.\n\nIf you did not request this, please ignore this email."
        - Use SmtpTransport::relay with credentials
        - Wrap lettre errors into String for simplicity
     c. Send email in tokio::spawn so it doesn't block the registration flow. Log errors but don't fail registration.

5. Update `backend/src/auth/mod.rs` to add `pub mod email;`
  </action>
  <verify>
Run `cd C:/Git/bbs/backend && cargo check` -- email and verification modules compile. `cargo test` passes.
  </verify>
  <done>Verification code generation produces 6-digit codes. DB operations store/validate codes with expiry. Email sending works with SMTP config or falls back to console logging for development.</done>
</task>

<task type="auto">
  <name>Task 2: Registration service with interactive terminal prompts</name>
  <files>
    backend/src/services/registration.rs
    backend/src/services/mod.rs
  </files>
  <action>
1. Create `backend/src/services/registration.rs`:

   The registration flow is an interactive, multi-step process. Since the existing Service trait uses synchronous on_enter/handle_input, registration needs to be a state machine that tracks which step the user is on.

   - Define `RegistrationState` enum:
     ```
     EnterHandle,
     EnterEmail,
     EnterPassword,
     ConfirmPassword,
     EnterVerificationCode,
     Complete,
     ```

   - NOTE: Registration is NOT implemented as a Service trait. It's a special-purpose flow that the Session drives directly. The Session will hold registration state and handle input routing. This is because:
     a. Registration needs async DB access (Service trait methods are sync)
     b. Registration needs password masking (requires special terminal handling)
     c. Registration is a pre-login flow, not a post-login service

   - Instead, create a `RegistrationFlow` struct:
     ```rust
     pub struct RegistrationFlow {
         state: RegistrationState,
         handle: Option<String>,
         email: Option<String>,
         password: Option<String>,
         verification_code: Option<String>,
         attempts: u32,
     }
     ```

   - `impl RegistrationFlow`:
     - `pub fn new() -> Self` -- starts at EnterHandle
     - `pub fn current_prompt(&self) -> &str` -- returns the prompt text for current state:
       - EnterHandle: "Choose your handle: "
       - EnterEmail: "Enter your email address: "
       - EnterPassword: "Choose a password: "
       - ConfirmPassword: "Confirm password: "
       - EnterVerificationCode: "Enter 6-digit verification code: "
       - Complete: "" (no prompt)
     - `pub fn needs_password_mask(&self) -> bool` -- true for EnterPassword and ConfirmPassword states
     - `pub async fn handle_input(&mut self, input: &str, pool: &SqlitePool, config: &Config) -> RegistrationResult`:
       This is the core state machine. Each state validates input and advances:

       **EnterHandle:**
       - Trim input
       - Call validate_handle(input) -- if Err, return RegistrationResult::Error(msg) (stay in EnterHandle)
       - Call handle_exists(pool, input) -- if true, return Error("That handle is already taken")
       - Store handle, advance to EnterEmail
       - Return RegistrationResult::Continue

       **EnterEmail:**
       - Trim input, lowercase
       - Call validate_email(input) -- if Err, return Error
       - Call email_exists(pool, input) -- if true, return Error("That email is already registered")
       - Store email, advance to EnterPassword
       - Return Continue

       **EnterPassword:**
       - Call validate_password(input) -- if Err, return Error
       - Store password, advance to ConfirmPassword
       - Return Continue

       **ConfirmPassword:**
       - Compare with stored password -- if mismatch, clear password, go back to EnterPassword, return Error("Passwords do not match")
       - If match: hash password with spawn_blocking(hash_password), create user in DB (email_verified = 0), generate verification code, store code in DB, send email (async spawn)
       - Advance to EnterVerificationCode
       - Return RegistrationResult::Message("Verification code sent to {email}") + Continue

       **EnterVerificationCode:**
       - Trim input
       - Call validate_verification_code(pool, email, input, "registration")
       - If valid: advance to Complete, return RegistrationResult::Complete(user_id)
       - If invalid: increment attempts. If attempts >= 3, return RegistrationResult::Failed("Too many attempts"). Otherwise return Error("Invalid code, try again")

   - Define `RegistrationResult` enum:
     ```rust
     pub enum RegistrationResult {
         Continue,                    // Show next prompt
         Error(String),               // Show error, re-show current prompt
         Message(String),             // Show message then continue to next prompt
         Complete(i64),               // Registration complete, user_id returned
         Failed(String),              // Registration failed permanently
     }
     ```

   - `pub fn render_registration_header(writer: &mut AnsiWriter)` -- renders a small ANSI art header for the registration screen:
     ```
     ┌──────────────────────────────────────────────────────────────┐
     │                    NEW USER REGISTRATION                     │
     └──────────────────────────────────────────────────────────────┘
     ```
     Use LightCyan for border, White bold for text.

2. Update `backend/src/services/mod.rs`:
   - Add `pub mod registration;`
   - Keep existing pub use statements

3. IMPORTANT password masking approach: When the session detects registration state needs_password_mask(), it should send a special terminal escape sequence to disable echo. For xterm.js, this is not directly possible over WebSocket text. Instead, the approach is:
   - Show asterisks server-side: When in password state, the session will NOT echo the typed characters. Instead, for each character received, send back a '*' character.
   - This requires the frontend to send individual characters, but currently it sends full lines (after Enter).
   - SIMPLER APPROACH: Since the frontend sends the full line after Enter, and the terminal shows what the user types locally, we need the backend to NOT send back what the user typed (which it doesn't already -- there's no echo from server). The terminal's local echo will show the typed text. For password masking, we rely on the frontend NOT showing characters -- but xterm.js has local echo by default for typed characters.
   - ACTUAL APPROACH: The password will be visible as typed (xterm.js local echo). After the user presses Enter, the server processes it. This matches many BBS systems. The asterisk display is a nice-to-have that requires client-side changes. For now, accept that passwords are shown during typing -- the terminal is a private session. Note: xterm.js does NOT have local echo by default for typed characters if we don't echo them back. Actually, looking at the websocket.ts, terminal.onData sends raw keystrokes to the server. The server currently doesn't echo anything back -- the welcome_art and services write output, but there's no character echo. So the user sees nothing as they type unless the server echoes.
   - CORRECT APPROACH: The current system has NO local echo. Users type and see nothing unless the server echoes back. This is how classic terminals work. So for password entry: echo '*' for each printable character received. For handle/email: echo the character back. This means the Session needs to handle character-by-character echo during registration. The frontend sends each keystroke (onData fires per keypress), and the server echoes appropriately.
   - In the registration flow: when in password state, for each printable character received, echo back '*'. For Enter (\r or \n), process the accumulated input. For Backspace (\x7f or \x08), remove last char from buffer and send backspace sequence (\x08 \x20 \x08). For other states, echo the character directly.
   - Add an `input_buffer: String` field to RegistrationFlow to accumulate character-by-character input.
   - Add `pub fn handle_char(&mut self, ch: char) -> Option<String>` that returns the echo string (the char itself, or '*', or backspace sequence). Returns None for control chars that don't need echo.
   - Add `pub fn take_input(&mut self) -> String` that takes and clears the input_buffer (called when Enter is received).
  </action>
  <verify>
Run `cd C:/Git/bbs/backend && cargo check` -- registration module compiles without errors. Verify that RegistrationFlow, RegistrationResult, RegistrationState, handle_char, take_input, and handle_input are all defined. Tests for state transitions, input validation, password masking echo, and backspace handling should be written as part of this task and pass with `cargo test`.
  </verify>
  <done>Registration flow is a complete state machine: handle -> email -> password (asterisk echo) -> confirm password -> verification code -> complete. Each step validates input, checks DB for uniqueness, and provides clear error messages. Character-by-character echo with password masking works correctly.</done>
</task>

</tasks>

<verification>
1. `cargo check` and `cargo test` pass
2. RegistrationFlow state machine covers all steps with proper validation
3. Password echo returns asterisks, handle/email echo returns typed character
4. Verification code flow: generate, store, validate all work
5. Email falls back to console logging when SMTP not configured
</verification>

<success_criteria>
- Registration collects handle, email, password, confirmation, and verification code
- Handle validated: 3-20 chars, alphanumeric + spaces, no profanity (rustrict), unique
- Email validated: basic format check, unique
- Password validated: 6-128 chars, shown as asterisks during entry
- Verification code: 6-digit, stored in DB with expiry, validated before account activation
- Email sent via SMTP if configured, otherwise code logged to console (dev mode)
- Proper error messages for every validation failure
- State machine handles backspace and character echo correctly
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-connection/02-04-SUMMARY.md`
</output>
