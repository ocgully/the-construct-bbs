---
phase: 02-authentication-connection
plan: 05
type: execute
wave: 4
depends_on: ["02-03", "02-04"]
files_modified:
  - backend/src/services/login.rs
  - backend/src/services/mod.rs
  - backend/src/websocket/session.rs
  - frontend/src/websocket.ts
autonomous: true

must_haves:
  truths:
    - "User can log in with handle and password through terminal prompts"
    - "Failed login shows error and re-prompts (with lockout after N attempts)"
    - "Successful login creates session token and sends it to frontend"
    - "Frontend stores session token in localStorage"
    - "Session persists across page refresh (token sent on reconnect)"
    - "Duplicate session blocked by default (sysop-configurable)"
    - "After login, user sees welcome-back message with last login date"
  artifacts:
    - path: "backend/src/services/login.rs"
      provides: "Interactive login flow with handle/password prompts"
      exports: ["LoginFlow", "LoginResult"]
    - path: "backend/src/websocket/session.rs"
      provides: "Session with auth state, login/registration routing, token persistence"
  key_links:
    - from: "backend/src/services/login.rs"
      to: "backend/src/auth/password.rs"
      via: "verify_password for login"
      pattern: "verify_password"
    - from: "backend/src/services/login.rs"
      to: "backend/src/auth/session.rs"
      via: "create_session after successful login"
      pattern: "create_session"
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/services/login.rs"
      via: "Session drives LoginFlow state machine"
      pattern: "LoginFlow"
    - from: "frontend/src/websocket.ts"
      to: "localStorage"
      via: "Store/retrieve session token"
      pattern: "localStorage.*bbs_session"
---

<objective>
Implement user login as an interactive terminal flow with session token persistence, allowing users to authenticate and resume sessions across page refreshes.

Purpose: Login is the second half of the auth gateway. Combined with the connection ceremony (Plan 03) and registration (Plan 04), this completes the "dial in -> authenticate -> enter BBS" flow. Session persistence ensures users don't lose their place on page refresh.

Output: Working login flow (handle -> password -> welcome), session token stored in localStorage, session resumption on reconnect, duplicate session blocking, and failed login lockout.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-authentication-connection/02-CONTEXT.md

@backend/src/websocket/session.rs
@backend/src/websocket/mod.rs
@backend/src/services/mod.rs
@backend/src/auth/mod.rs
@backend/src/config.rs
@frontend/src/websocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Login flow state machine</name>
  <files>
    backend/src/services/login.rs
    backend/src/services/mod.rs
    backend/src/db/login_attempts.rs
    backend/src/db/mod.rs
  </files>
  <action>
1. Create `backend/src/db/login_attempts.rs`:
   - `pub async fn record_login_attempt(pool: &SqlitePool, handle: &str, success: bool) -> Result<(), sqlx::Error>` -- INSERT into login_attempts
   - `pub async fn get_recent_failures(pool: &SqlitePool, handle: &str, window_minutes: u32) -> Result<i64, sqlx::Error>` -- COUNT failed attempts in the last N minutes for this handle
   - `pub async fn is_locked_out(pool: &SqlitePool, handle: &str, max_attempts: u32, lockout_minutes: u32) -> Result<bool, sqlx::Error>` -- Returns true if recent failures >= max_attempts within lockout window

2. Update `backend/src/db/mod.rs` to add `pub mod login_attempts;`

3. Create `backend/src/services/login.rs`:

   Like registration, login is a state machine driven by the Session, NOT a Service trait impl.

   - Define `LoginState` enum:
     ```
     EnterHandle,
     EnterPassword { handle: String },
     ```

   - Define `LoginFlow` struct:
     ```rust
     pub struct LoginFlow {
         state: LoginState,
         input_buffer: String,
         failed_attempts: u32,
     }
     ```

   - `impl LoginFlow`:
     - `pub fn new() -> Self` -- starts at EnterHandle
     - `pub fn current_prompt(&self) -> &str`:
       - EnterHandle: "Enter your handle: "
       - EnterPassword: "Password: "
     - `pub fn needs_password_mask(&self) -> bool` -- true for EnterPassword
     - `pub fn handle_char(&mut self, ch: char) -> Option<String>` -- Same logic as RegistrationFlow: echo char normally, or '*' for password, handle backspace. Accumulate in input_buffer.
     - `pub fn take_input(&mut self) -> String` -- take and clear input_buffer
     - `pub async fn handle_input(&mut self, input: &str, pool: &SqlitePool, config: &Config) -> LoginResult`:

       **EnterHandle:**
       - Trim input
       - If empty, return LoginResult::Error("Handle cannot be empty")
       - If input is "new" (case-insensitive), return LoginResult::SwitchToRegistration (user wants to register)
       - Check lockout: call is_locked_out(pool, input, config.auth.max_login_attempts, config.auth.lockout_minutes). If locked out, return LoginResult::Error("Account temporarily locked. Try again later.")
       - Look up user: find_user_by_handle(pool, input). If None, return LoginResult::Error("Handle not found. Type 'new' to register.")
       - If user found but email_verified == 0, return LoginResult::Error("Account not verified. Please complete email verification.")
       - Advance to EnterPassword { handle: input.to_string() }
       - Return LoginResult::Continue

       **EnterPassword { handle }:**
       - Call verify_password(input, &user.password_hash) using spawn_blocking (Argon2 is CPU-intensive)
       - Record login attempt (success or failure)
       - If password wrong:
         - Increment failed_attempts
         - If failed_attempts >= config.auth.max_login_attempts, return LoginResult::Locked
         - If failed_attempts >= 1, include "Forgot password? Type 'reset' at handle prompt" in error
         - Return LoginResult::Error("Invalid password") and go back to EnterHandle
       - If password correct:
         - Check duplicate session: get_active_session_for_user(pool, user.id). If exists, return LoginResult::Error("You are already connected from another session")
         - Update last_login and total_logins
         - Create session token: create_session(pool, user.id, None, config.auth.session_duration_hours)
         - Determine user_level: if user.handle is in config.auth.sysop_handles (case-insensitive), level is "Sysop", else use stored level
         - Return LoginResult::Success { user_id, handle, token, user_level, last_login }

   - Define `LoginResult` enum:
     ```rust
     pub enum LoginResult {
         Continue,
         Error(String),
         Success {
             user_id: i64,
             handle: String,
             token: String,
             user_level: String,
             last_login: Option<String>,
         },
         SwitchToRegistration,
         Locked,
     }
     ```

   - `pub fn render_login_header(writer: &mut AnsiWriter, tagline: &str, active_nodes: usize, max_nodes: usize)`:
     Renders the login screen header with BBS name, tagline, and node count:
     ```
     ┌──────────────────────────────────────────────────────────────┐
     │              THE CONSTRUCT BBS                               │
     │              "Welcome to The Construct BBS"                  │
     │                                                              │
     │              Node 3 of 16 -- 13 lines available              │
     │                                                              │
     │    Enter your handle or type 'new' to register              │
     └──────────────────────────────────────────────────────────────┘
     ```
     Use LightCyan for borders, Yellow bold for BBS name, LightGreen for tagline, White for node info.

4. Update `backend/src/services/mod.rs` to add `pub mod login;`
  </action>
  <verify>
Run `cd C:/Git/bbs/backend && cargo check` -- login module compiles. `cargo test` -- test state transitions, especially:
- Empty handle rejected
- "new" triggers SwitchToRegistration
- Wrong password increments failures and returns Error
- Lockout after max attempts
  </verify>
  <done>Login flow handles: handle entry -> password verification -> session creation. Lockout after configurable failed attempts. Duplicate session detection. "new" command switches to registration. Password masking with asterisks.</done>
</task>

<task type="auto">
  <name>Task 2: Session auth state management and token persistence</name>
  <files>
    backend/src/websocket/session.rs
    frontend/src/websocket.ts
  </files>
  <action>
This task is complex -- follow these steps in order. Steps 1-3 are backend (session.rs), step 4 is frontend (websocket.ts), step 5 is the welcome message format.

**Step 1: Define AuthState enum in session.rs**

Add an `AuthState` enum to Session:
```rust
enum AuthState {
    AwaitingAuth,           // Waiting for frontend auth message
    ConnectionCeremony,     // Running ceremony (handled by on_connect)
    Login(LoginFlow),       // In login flow
    Registration(RegistrationFlow), // In registration flow
    Authenticated {         // Logged in
        user_id: i64,
        handle: String,
        token: String,
        user_level: String,
        login_time: std::time::Instant,
    },
}
```

Add `auth_state: AuthState` field to Session (initialize to AwaitingAuth).

**Step 2: Modify on_connect() for ceremony-to-login transition**

After connection ceremony completes successfully, set auth_state to Login(LoginFlow::new()), render login header using render_login_header() with tagline from config and node counts from node_manager, then send the first login prompt.

**Step 3: Modify handle_input() for auth routing**

Before the existing service routing logic, check auth_state:

- If AwaitingAuth: parse incoming JSON message for { type: "auth", token: ... }. If token is not null, try validate_session(). If valid, look up user, set auth_state to Authenticated, send welcome-back message, show main menu. If invalid/expired, set auth_state to ConnectionCeremony and run ceremony + login flow. If token is null, run ceremony + login flow.

- If Login(flow): handle character-by-character input:
  - For printable chars (not \r, \n, \x7f, \x08): call flow.handle_char(ch) and echo result
  - For Enter (\r or \n): call flow.take_input(), then flow.handle_input(input, pool, config).await
  - For Backspace (\x7f or \x08): call flow.handle_char('\x08') and echo result
  - Process LoginResult:
    - Continue: send next prompt with appropriate color
    - Error(msg): display error in LightRed, re-show current prompt
    - Success: transition to Authenticated state, update node_manager with real user info (release placeholder, assign with real handle), **send session token to frontend via the tx channel as a JSON message**: `tx.send(serde_json::to_string(&serde_json::json!({"type":"session","token":token})).unwrap()).await` -- this is how the frontend receives the token to store in localStorage. Then display welcome-back message and show main menu.
    - SwitchToRegistration: transition to Registration(RegistrationFlow::new()), show registration header and first prompt
    - Locked: display lockout message, disconnect

- If Registration(flow): same character-by-character handling as login:
  - Process RegistrationResult:
    - Continue: send next prompt
    - Error(msg): display error, re-show current prompt
    - Message(msg): display message in Yellow, then send next prompt
    - Complete(user_id): display "Registration complete! You can now log in." in LightGreen, transition to Login(LoginFlow::new()), show login prompt
    - Failed(msg): display error, disconnect or restart registration

- If Authenticated: run existing service routing logic (current_service handling, main menu, etc.)

**Important input handling change:**
The current handle_input receives complete lines (the frontend sends on Enter via terminal.onData). But for character-by-character echo during login/registration, we need individual character handling. Looking at the frontend websocket.ts, terminal.onData fires for EACH character typed (or each key event). The WebSocket sends each data event. So the server already receives character-by-character input.

However, the current session.handle_input() treats each input as a complete command. We need to change behavior based on auth_state:
- In Login/Registration states: accumulate characters, echo them, process on Enter
- In Authenticated state: the existing behavior works (services expect complete lines since the terminal onData sends each keypress but services treat each keystroke as input)

**Step 4: Update frontend/src/websocket.ts**

- In ws.onmessage, check if the received data is JSON with type "session": try JSON.parse, if it has type === "session", store token in localStorage: `localStorage.setItem('bbs_session_token', data.token)`. Don't write JSON messages to terminal.
- In ws.onopen, check localStorage for token and send auth message (this may already be added in Plan 03 Task 1 -- ensure it's present):
  ```typescript
  const token = localStorage.getItem('bbs_session_token');
  ws.send(JSON.stringify({ type: 'auth', token: token }));
  ```
- On explicit logout (if we receive a "logout" type message), clear the token: `localStorage.removeItem('bbs_session_token')`

**Step 5: Welcome-back message format (shown after successful login)**
```
────────────────────────────────────────────────────────────────
  Welcome back, DarkAngel!
  Last login: January 25, 2026 at 3:42 PM
  Total calls: 47
────────────────────────────────────────────────────────────────
```
Use Yellow for handle, LightCyan for stats, DarkGray for border lines.
Follow with a 1-second pause, then show main menu.
  </action>
  <verify>
Run `cd C:/Git/bbs/backend && cargo check` -- session compiles with auth state machine. `cd C:/Git/bbs/frontend && npm run build` -- frontend compiles with token handling.
  </verify>
  <done>Session manages full auth lifecycle: auth token check -> ceremony -> login/register -> authenticated. Token stored in localStorage and sent on reconnect. Session persists across page refresh. Welcome-back message shown with last login info. Duplicate sessions blocked.</done>
</task>

</tasks>

<verification>
1. `cargo check` and `cargo test` pass for backend
2. `npm run build` passes for frontend
3. Manual test flow: connect -> ceremony -> type handle -> type password -> see welcome -> see main menu
4. Manual test: refresh page -> reconnects with stored token -> skips ceremony -> goes to main menu
5. Manual test: type "new" at handle prompt -> switches to registration flow
6. Manual test: wrong password 5 times -> lockout message
</verification>

<success_criteria>
- Login flow: handle -> password (asterisks) -> session created -> welcome-back message -> main menu
- Session token sent to frontend as JSON via tx.send(), stored in localStorage
- Page refresh: token sent on reconnect, session validated, user returns to main menu (no re-login)
- "new" at handle prompt switches to registration
- Failed login: clear error message, re-prompt, lockout after N attempts
- Duplicate session: second connection blocked with message
- Character-by-character echo works: normal chars echoed in login, asterisks in password
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-connection/02-05-SUMMARY.md`
</output>
