---
phase: 02-authentication-connection
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - frontend/public/audio/modem.mp3
  - frontend/src/audio.ts
  - frontend/src/main.ts
  - frontend/src/websocket.ts
  - backend/src/connection/ceremony.rs
  - backend/src/connection/mod.rs
  - backend/src/services/welcome_art.rs
  - backend/src/websocket/session.rs
autonomous: true

must_haves:
  truths:
    - "User hears modem handshake sound when connecting to BBS"
    - "User sees typewriter-paced connection text (Connecting, Negotiating, ANSI detected, Node assignment)"
    - "User sees ANSI art splash screen with line-by-line reveal"
    - "User receives line-busy message and disconnect when max nodes reached"
    - "Connection ceremony is paced by server-side delays (not client setTimeout)"
  artifacts:
    - path: "frontend/public/audio/modem.mp3"
      provides: "Modem handshake sound effect file"
    - path: "frontend/src/audio.ts"
      provides: "Web Audio API modem sound playback with user gesture handling"
      exports: ["loadModemSound", "playModemSound"]
    - path: "backend/src/connection/ceremony.rs"
      provides: "Server-side connection ceremony with typewriter pacing"
      exports: ["run_connection_ceremony", "send_line_busy"]
  key_links:
    - from: "frontend/src/audio.ts"
      to: "frontend/public/audio/modem.mp3"
      via: "fetch('/audio/modem.mp3')"
      pattern: "fetch.*audio.*modem"
    - from: "backend/src/connection/ceremony.rs"
      to: "backend/src/connection/node_manager.rs"
      via: "node_manager.assign_node() and get_status()"
      pattern: "node_manager"
    - from: "backend/src/websocket/session.rs"
      to: "backend/src/connection/ceremony.rs"
      via: "on_connect calls ceremony"
      pattern: "run_connection_ceremony"
---

<objective>
Implement the BBS connection ceremony: modem handshake audio, typewriter-paced terminal text simulation, ANSI splash screen reveal, node assignment display, and line-busy rejection.

Purpose: The connection ceremony is the emotional core of the BBS experience -- the feeling of "dialing in" to an exclusive system. This happens before any authentication, setting the atmosphere for every visit.

Output: Modem sound plays in browser, server delivers typewriter-paced connection text over WebSocket, ANSI splash art renders line-by-line, node count shown, and line-busy users get rejected with busy signal message.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-authentication-connection/02-CONTEXT.md
@.planning/phases/02-authentication-connection/02-RESEARCH.md

@backend/src/websocket/session.rs
@backend/src/websocket/mod.rs
@backend/src/services/welcome_art.rs
@backend/src/terminal/ansi.rs
@backend/src/config.rs
@frontend/src/main.ts
@frontend/src/websocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Frontend modem audio and connection ceremony trigger</name>
  <files>
    frontend/public/audio/modem.mp3
    frontend/src/audio.ts
    frontend/src/main.ts
    frontend/src/websocket.ts
  </files>
  <action>
1. Create `frontend/public/` directory and `frontend/public/audio/` subdirectory.

2. Generate or download a modem handshake sound effect. Use a short (~3-5 second) MP3 file. Options:
   - Download a public domain modem sound from the internet using curl/wget
   - If no reliable download available, create a minimal placeholder MP3 and leave a comment noting it should be replaced with an authentic modem sound
   - The file should be at `frontend/public/audio/modem.mp3`
   - IMPORTANT: Also ensure Vite serves the public/ directory (Vite does this automatically for files in public/)

3. Create `frontend/src/audio.ts`:
   ```typescript
   let audioContext: AudioContext | null = null;
   let modemBuffer: AudioBuffer | null = null;
   let loaded = false;

   export async function loadModemSound(): Promise<void> {
     try {
       const response = await fetch('/audio/modem.mp3');
       if (!response.ok) {
         console.warn('Modem sound not found, skipping audio');
         return;
       }
       const arrayBuffer = await response.arrayBuffer();
       audioContext = new AudioContext();
       modemBuffer = await audioContext.decodeAudioData(arrayBuffer);
       loaded = true;
     } catch (e) {
       console.warn('Failed to load modem sound:', e);
     }
   }

   export async function playModemSound(): Promise<void> {
     if (!loaded || !audioContext || !modemBuffer) return;

     // Resume AudioContext if suspended (browser autoplay policy)
     if (audioContext.state === 'suspended') {
       await audioContext.resume();
     }

     const source = audioContext.createBufferSource();
     source.buffer = modemBuffer;
     source.connect(audioContext.destination);
     source.start(0);
   }

   export function isAudioLoaded(): boolean {
     return loaded;
   }
   ```

4. Update `frontend/src/main.ts`:
   - Import `{ loadModemSound, playModemSound }` from './audio'
   - After DOMContentLoaded, call `loadModemSound()` early (preload)
   - Replace the direct `connectWebSocket(terminal)` call with a "Connect" interaction flow:
     a. Show a connect prompt in the terminal: display "Press ENTER to connect..." text
     b. Listen for a single keypress (any key) using terminal.onData once
     c. On keypress: call `playModemSound()` (requires user gesture for AudioContext), then call `connectWebSocket(terminal)`
     d. This satisfies browser autoplay policy by playing audio after user interaction
   - The connect prompt serves double duty: user gesture for audio AND atmospheric "picking up the phone" moment

5. Update `frontend/src/websocket.ts`:
   - In the ws.onopen handler, remove the "Connected to The Construct BBS" writeln calls -- the server now handles the entire connection ceremony text
   - Keep the terminal.clear() call in onopen so the connect prompt disappears
   - The server will send all ceremony text via WebSocket messages
   - Add a protocol for the frontend to send its session token on connect. In ws.onopen, check `localStorage.getItem('bbs_session_token')`. If exists, send as first message: `JSON.stringify({ type: 'auth', token: storedToken })`. If no token, send `JSON.stringify({ type: 'auth', token: null })`. This enables session resumption in Plan 05.
  </action>
  <verify>
Run `cd C:/Git/bbs/frontend && npm run build` -- should compile successfully. Verify audio.ts exports, main.ts has connect prompt, websocket.ts sends auth message on connect.
  </verify>
  <done>Frontend loads modem sound, plays it on user keypress, sends auth token message on WebSocket connect. Browser autoplay policy satisfied by user gesture requirement.</done>
</task>

<task type="auto">
  <name>Task 2: Backend connection ceremony and line-busy logic</name>
  <files>
    backend/src/connection/ceremony.rs
    backend/src/connection/mod.rs
    backend/src/services/welcome_art.rs
    backend/src/websocket/session.rs
    backend/src/websocket/mod.rs
  </files>
  <action>
1. Create `backend/src/connection/ceremony.rs`:
   - `pub async fn run_connection_ceremony(tx: &mpsc::Sender<String>, node_manager: &NodeManager, config: &ConnectionConfig) -> Result<usize, String>`:
     a. First check node availability via node_manager.get_status(). If full, call send_line_busy(tx) and return Err.
     b. Use AnsiWriter to build each ceremony line with appropriate colors.
     c. Send lines one at a time over tx channel with tokio::time::sleep delays between them. Use config.baud_simulation_cps to calculate delay: delay_ms = (line_visible_length * 1000) / baud_cps. Minimum delay 100ms per line for readability.
     d. Ceremony lines (use Green for system text, LightCyan for values, Yellow for emphasis):
        - "" (blank line)
        - "ATDT 555-0199" (LightGreen, simulating dial command)
        - sleep 500ms
        - "CONNECT 38400" (Yellow, bold)
        - sleep 300ms
        - "" (blank)
        - "Negotiating protocols..." (Green)
        - sleep 400ms
        - "ANSI/CP437 terminal detected." (Green)
        - sleep 300ms
        - "" (blank)
        - "Connecting to The Construct BBS..." (LightCyan, bold)
        - sleep 600ms
     e. Note: node assignment happens AFTER ceremony text, during login (Plan 05). The ceremony just checks availability. Return a temporary node_id of 0 as placeholder -- actual node assignment will be wired in Plan 07 when the full flow is integrated.
     f. Actually, reconsider: assign node eagerly here. Call node_manager.assign_node(0, "connecting".to_string()) with a placeholder. The node will be updated with real user info after login. This ensures accurate node counts during ceremony. Return the assigned node_id.
     g. After ceremony text, show node info:
        - `format!("Connected to Node {} of {}", node_id, max_nodes)` (Yellow)
        - "" (blank)

   - `pub async fn send_line_busy(tx: &mpsc::Sender<String>)`:
     a. Use AnsiWriter to build a box-drawn "ALL LINES BUSY" message in LightRed
     b. Include CP437 box-drawing characters for authentic look:
        ```
        ┌──────────────────────────────────────────┐
        │   ALL LINES ARE BUSY - PLEASE TRY AGAIN  │
        │                                          │
        │   The Construct BBS - 0 nodes available  │
        └──────────────────────────────────────────┘
        ```
     c. Send via tx, then sleep 3 seconds before returning (gives user time to read)

   - `pub async fn send_splash_screen(tx: &mpsc::Sender<String>, baud_cps: u32)`:
     a. Create an ANSI art splash screen for The Construct BBS. Use CP437 box-drawing and CGA colors. Design a compact but atmospheric splash (15-20 lines max). Include BBS name, a tagline, and decorative borders.
     b. Send line-by-line with baud-rate delay between lines: delay_ms = (line_length * 1000) / baud_cps. Minimum 50ms per line.
     c. Use begin_sync/end_sync around each line to prevent tearing.

   - Helper: `async fn send_ceremony_line(tx: &mpsc::Sender<String>, text: &str)` -- sends a single ANSI-formatted line via tx channel. Appends \r\n.

2. Update `backend/src/connection/mod.rs` to add `pub mod ceremony;`

3. Update `backend/src/websocket/session.rs`:
   - The session now needs to handle the connection ceremony as the first thing on connect. Modify `on_connect()`:
     a. Instead of immediately showing welcome_art, run the connection ceremony
     b. Call `connection::ceremony::run_connection_ceremony(&self.tx, &self.state.node_manager, &self.state.config.connection).await`
     c. If ceremony returns Err (line busy), the session should be terminated. Set a flag `self.disconnecting = true` or similar. The WebSocket handler will close the connection.
     d. If ceremony returns Ok(node_id), store node_id in session: add `node_id: Option<usize>` field to Session struct
     e. After ceremony, call `send_splash_screen(&self.tx, self.state.config.connection.baud_simulation_cps).await`
     f. After splash, show a blank line then the login/register prompt (for now, just show "Enter your handle:" as placeholder -- Plan 05 implements the full login flow)
   - Add `node_id: Option<usize>` field to Session struct, initialize to None in new()
   - Add `disconnecting: bool` field, initialize to false
   - Update on_disconnect() to release node: if self.node_id is Some, call self.state.node_manager.release_node(node_id).await

4. Update `backend/src/websocket/mod.rs`:
   - The handle_socket function needs to pass node_manager access. Since Session already has Arc<AppState> which now contains node_manager, no signature changes needed.
   - However, we need to make on_connect async-aware of the ceremony result. Currently on_connect returns nothing. Change it to return a bool: true = continue, false = disconnect (line busy). If false, skip the recv_task and close cleanly.

5. IMPORTANT: The session currently uses synchronous Service trait methods. The ceremony needs async. The Session.on_connect() is already async, so call ceremony functions directly using self.tx (the mpsc sender) and self.state references. The ceremony writes directly to tx, bypassing the output_buffer for direct streaming with timing control.
  </action>
  <verify>
Run `cd C:/Git/bbs/backend && cargo check` -- ceremony module compiles, session integrates ceremony on connect. Run `cd C:/Git/bbs/backend && cargo test` for existing tests.
  </verify>
  <done>Connection ceremony delivers typewriter-paced text over WebSocket. ANSI splash screen renders line-by-line with baud simulation. Line-busy users see rejection message and get disconnected. Node assignment happens during ceremony. Frontend plays modem sound on user gesture.</done>
</task>

</tasks>

<verification>
1. `cargo check` passes for both backend and frontend
2. `npm run build` passes for frontend
3. Manual test: start server, open browser, press key to connect, hear modem sound (if audio file present), see connection ceremony text appear line-by-line, see splash art, see login prompt
4. Manual test: set max_nodes = 1 in config, connect two browsers, second should see "ALL LINES BUSY"
</verification>

<success_criteria>
- Modem handshake audio plays in browser after user keypress (AudioContext resumed via user gesture)
- Connection ceremony text appears line-by-line with visible pacing (server-controlled delays)
- ANSI art splash screen renders with baud-rate simulation
- Node assignment shown: "Connected to Node X of Y"
- Line-busy scenario: full-capacity users see ANSI rejection message and connection closes
- Frontend sends auth token on WebSocket open (enables session resumption in Plan 05)
- Node released on disconnect
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-connection/02-03-SUMMARY.md`
</output>
