---
phase: 02-authentication-connection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/Cargo.toml
  - backend/src/db/mod.rs
  - backend/src/db/pool.rs
  - backend/src/db/schema.sql
  - backend/src/db/user.rs
  - backend/src/config.rs
  - config.toml
  - backend/src/main.rs
autonomous: true

must_haves:
  truths:
    - "SQLite database initializes on server startup with WAL mode and foreign keys enabled"
    - "User table exists with all profile fields, stats, and proper constraints"
    - "Session and verification_codes tables exist with foreign key relationships"
    - "Config file contains auth, connection, and email sections with sysop-configurable defaults"
  artifacts:
    - path: "backend/src/db/mod.rs"
      provides: "Database module re-exports"
    - path: "backend/src/db/pool.rs"
      provides: "SQLx pool initialization with WAL mode"
      exports: ["init_pool"]
    - path: "backend/src/db/schema.sql"
      provides: "Complete SQLite schema"
      contains: "CREATE TABLE users"
    - path: "backend/src/db/user.rs"
      provides: "User CRUD operations"
      exports: ["User", "create_user", "find_user_by_handle", "find_user_by_email"]
    - path: "backend/src/config.rs"
      provides: "Extended config with auth/connection/email sections"
      contains: "AuthConfig"
  key_links:
    - from: "backend/src/main.rs"
      to: "backend/src/db/pool.rs"
      via: "init_pool called at startup"
      pattern: "init_pool"
    - from: "backend/src/db/user.rs"
      to: "backend/src/db/schema.sql"
      via: "queries match schema columns"
      pattern: "sqlx::query"
---

<objective>
Set up the SQLite database layer with SQLx and extend the config system with all Phase 2 configuration sections.

Purpose: Every auth, session, and connection feature depends on database storage and sysop-configurable settings. This plan establishes the data foundation that all subsequent plans build on.

Output: Working SQLx pool initialization, complete schema with users/sessions/verification_codes tables, User CRUD operations, and config.toml sections for auth, connection, and email settings.
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-connection/02-RESEARCH.md

@backend/Cargo.toml
@backend/src/main.rs
@backend/src/config.rs
@config.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and create SQLite database module</name>
  <files>
    backend/Cargo.toml
    backend/src/db/mod.rs
    backend/src/db/pool.rs
    backend/src/db/schema.sql
  </files>
  <action>
1. Add new dependencies to backend/Cargo.toml:
   ```toml
   sqlx = { version = "0.8", features = ["runtime-tokio", "sqlite"] }
   argon2 = "0.5"
   uuid = { version = "1.11", features = ["v4", "fast-rng"] }
   rustrict = "0.7"
   rand = "0.8"
   chrono = { version = "0.4", features = ["serde"] }
   ```
   Note: lettre is NOT added yet -- it will be added in Plan 04 (Registration) when email is actually needed. Keep dependencies minimal.

2. Create `backend/src/db/mod.rs` with:
   ```rust
   pub mod pool;
   pub mod user;
   ```

3. Create `backend/src/db/pool.rs` with:
   - `pub async fn init_pool(database_url: &str) -> Result<SqlitePool, sqlx::Error>` function
   - Connect to SQLite using `SqlitePoolOptions::new().max_connections(5)`
   - Enable WAL mode: `PRAGMA journal_mode = WAL`
   - Enable foreign keys: `PRAGMA foreign_keys = ON`
   - Run schema from embedded SQL file using `sqlx::query(include_str!("schema.sql"))`. Note: SQLx cannot execute multiple statements in one query call. Split the schema.sql content by semicolons and execute each statement individually in a loop, skipping empty strings.
   - Return the pool

4. Create `backend/src/db/schema.sql` with the complete schema:
   - `users` table: id INTEGER PRIMARY KEY, handle TEXT UNIQUE NOT NULL, handle_lower TEXT UNIQUE NOT NULL (for case-insensitive lookups), email TEXT UNIQUE NOT NULL, email_verified INTEGER NOT NULL DEFAULT 0, password_hash TEXT NOT NULL, real_name TEXT, location TEXT, signature TEXT, bio TEXT, user_level TEXT NOT NULL DEFAULT 'User' (values: 'User', 'Sysop'), created_at TEXT NOT NULL DEFAULT (datetime('now')), last_login TEXT, total_logins INTEGER NOT NULL DEFAULT 0, total_time_minutes INTEGER NOT NULL DEFAULT 0, messages_sent INTEGER NOT NULL DEFAULT 0, games_played INTEGER NOT NULL DEFAULT 0
   - `sessions` table: token TEXT PRIMARY KEY, user_id INTEGER NOT NULL, node_id INTEGER, created_at TEXT NOT NULL DEFAULT (datetime('now')), last_activity TEXT NOT NULL DEFAULT (datetime('now')), expires_at TEXT NOT NULL, FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
   - `verification_codes` table: id INTEGER PRIMARY KEY, email TEXT NOT NULL, code TEXT NOT NULL, code_type TEXT NOT NULL DEFAULT 'registration' (values: 'registration', 'password_reset'), created_at TEXT NOT NULL DEFAULT (datetime('now')), expires_at TEXT NOT NULL, used INTEGER NOT NULL DEFAULT 0
   - `login_attempts` table: id INTEGER PRIMARY KEY, handle TEXT NOT NULL, ip_address TEXT, attempted_at TEXT NOT NULL DEFAULT (datetime('now')), success INTEGER NOT NULL DEFAULT 0
   - Indexes: idx_sessions_user_id ON sessions(user_id), idx_sessions_expires ON sessions(expires_at), idx_verification_expires ON verification_codes(expires_at), idx_login_attempts_handle ON login_attempts(handle), idx_users_handle_lower ON users(handle_lower), idx_users_email ON users(email)
   - DO NOT include PRAGMA statements in schema.sql -- those are set in pool.rs
  </action>
  <verify>
Run `cd C:/Git/bbs/backend && cargo check` -- should compile with new dependencies and db module.
  </verify>
  <done>Database module compiles. Schema SQL file exists with all tables and indexes. Pool initialization function handles WAL mode, foreign keys, and schema execution.</done>
</task>

<task type="auto">
  <name>Task 2: Create User CRUD operations and extend config</name>
  <files>
    backend/src/db/user.rs
    backend/src/config.rs
    config.toml
    backend/src/main.rs
  </files>
  <action>
1. Create `backend/src/db/user.rs` with:
   - `User` struct (all fields from users table, derives: Debug, Clone, sqlx::FromRow, serde::Serialize)
   - `pub async fn create_user(pool: &SqlitePool, handle: &str, email: &str, password_hash: &str) -> Result<User, sqlx::Error>` -- inserts user with handle_lower = handle.to_lowercase(), returns the created user via RETURNING or separate SELECT
   - `pub async fn find_user_by_handle(pool: &SqlitePool, handle: &str) -> Result<Option<User>, sqlx::Error>` -- case-insensitive lookup via handle_lower column
   - `pub async fn find_user_by_email(pool: &SqlitePool, email: &str) -> Result<Option<User>, sqlx::Error>`
   - `pub async fn find_user_by_id(pool: &SqlitePool, id: i64) -> Result<Option<User>, sqlx::Error>`
   - `pub async fn update_last_login(pool: &SqlitePool, user_id: i64) -> Result<(), sqlx::Error>` -- sets last_login to now, increments total_logins
   - `pub async fn update_user_time(pool: &SqlitePool, user_id: i64, minutes: i64) -> Result<(), sqlx::Error>` -- adds minutes to total_time_minutes
   - `pub async fn handle_exists(pool: &SqlitePool, handle: &str) -> Result<bool, sqlx::Error>` -- checks handle_lower
   - `pub async fn email_exists(pool: &SqlitePool, email: &str) -> Result<bool, sqlx::Error>`
   - `pub async fn delete_user(pool: &SqlitePool, user_id: i64) -> Result<(), sqlx::Error>`
   - Use `sqlx::query` and `sqlx::query_as` (NOT compile-time macros `sqlx::query!` -- those require DATABASE_URL at compile time which we don't want). Use string-based queries with .bind().

2. Extend `backend/src/config.rs` with new config sections (keep existing ServerConfig, TerminalConfig, ServiceConfig):
   - Add to Config struct: `pub auth: AuthConfig`, `pub connection: ConnectionConfig`, `pub email: Option<EmailConfig>`
   - `AuthConfig` struct: max_login_attempts (u32, default 5), lockout_minutes (u32, default 15), session_duration_hours (u32, default 24), verification_code_expiry_hours (u32, default 24), sysop_handles (Vec<String>, default empty)
   - `ConnectionConfig` struct: max_nodes (u16, default 16), baud_simulation_cps (u32, default 960 -- simulates 9600 baud), line_busy_mode (String, default "disconnect" -- "disconnect" or "queue"), idle_timeout_minutes (u32, default 15), idle_warning_bell (bool, default true), ceremony_skippable (bool, default false), tagline (String, default "Welcome to The Construct BBS"), show_last_callers (bool, default true)
   - `EmailConfig` struct (optional): smtp_host (String), smtp_port (u16, default 587), smtp_username (String), smtp_password (String), from_address (String), from_name (String, default "The Construct BBS")
   - Use `#[serde(default)]` on all config structs so they have sensible defaults when omitted from config.toml. Implement Default for AuthConfig, ConnectionConfig.

3. Update `config.toml` with new sections (all using defaults, showing structure):
   ```toml
   [auth]
   max_login_attempts = 5
   lockout_minutes = 15
   session_duration_hours = 24
   verification_code_expiry_hours = 24
   sysop_handles = ["Sysop"]

   [connection]
   max_nodes = 16
   baud_simulation_cps = 960
   line_busy_mode = "disconnect"
   idle_timeout_minutes = 15
   idle_warning_bell = true
   ceremony_skippable = false
   tagline = "Welcome to The Construct BBS"
   show_last_callers = true
   ```

4. Update `backend/src/main.rs`:
   - Add `mod db;` declaration
   - In main(), after loading config: call `db::pool::init_pool("sqlite:bbs.db?mode=rwc")` to initialize the database pool (mode=rwc creates file if not exists)
   - Add `db_pool: SqlitePool` to `AppState` struct (add `use sqlx::SqlitePool;`)
   - Pass pool into AppState
   - Print "Database initialized" after pool creation
  </action>
  <verify>
Run `cd C:/Git/bbs/backend && cargo check` -- should compile with extended config and database integration in main. Run `cd C:/Git/bbs/backend && cargo test` for any existing tests.
  </verify>
  <done>User CRUD functions compile and match schema. Config parses new auth/connection/email sections with defaults. AppState includes SqlitePool. Server startup initializes database.</done>
</task>

</tasks>

<verification>
1. `cargo check` passes in backend directory
2. `cargo test` passes (existing tests still work)
3. Config loads successfully with new sections (verify via `cargo run` starting server)
4. Database file `bbs.db` created on server startup
5. Schema tables exist (can verify by stopping server and running `sqlite3 bbs.db ".tables"`)
</verification>

<success_criteria>
- SQLx pool initializes with WAL mode and foreign keys on server startup
- All 4 tables (users, sessions, verification_codes, login_attempts) created with proper columns and indexes
- User CRUD operations compile against schema
- Config.toml has auth, connection, and email sections with sysop-configurable values
- AppState carries SqlitePool for use by all handlers
- Existing Phase 1 functionality unbroken (health check, WebSocket, services)
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-connection/02-01-SUMMARY.md`
</output>
