---
phase: 02-authentication-connection
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/src/auth/mod.rs
  - backend/src/auth/password.rs
  - backend/src/auth/session.rs
  - backend/src/auth/validation.rs
  - backend/src/connection/mod.rs
  - backend/src/connection/node_manager.rs
  - backend/src/main.rs
autonomous: true

must_haves:
  truths:
    - "Passwords are hashed with Argon2id using OWASP 2026 parameters"
    - "Session tokens are cryptographically secure UUID v4"
    - "Handle validation rejects profanity including leetspeak variants"
    - "Handle validation enforces 3-20 chars, alphanumeric + spaces"
    - "Node manager tracks active connections and enforces max_nodes limit"
    - "Node assignment gives first available node number"
  artifacts:
    - path: "backend/src/auth/password.rs"
      provides: "Argon2id password hashing and verification"
      exports: ["hash_password", "verify_password"]
    - path: "backend/src/auth/session.rs"
      provides: "Session token generation and DB operations"
      exports: ["create_session", "validate_session", "delete_session"]
    - path: "backend/src/auth/validation.rs"
      provides: "Handle and email validation with profanity filter"
      exports: ["validate_handle", "validate_email"]
    - path: "backend/src/connection/node_manager.rs"
      provides: "Node tracking with RwLock<HashMap>"
      exports: ["NodeManager"]
  key_links:
    - from: "backend/src/auth/password.rs"
      to: "argon2 crate"
      via: "Argon2id with OWASP params"
      pattern: "Argon2::new"
    - from: "backend/src/auth/session.rs"
      to: "backend/src/db/user.rs"
      via: "SQLx queries for session table"
      pattern: "sqlx::query"
    - from: "backend/src/connection/node_manager.rs"
      to: "backend/src/main.rs"
      via: "NodeManager added to AppState"
      pattern: "NodeManager"
---

<objective>
Build the authentication core (password hashing, session management, input validation) and node manager for connection scarcity.

Purpose: These are the building blocks that registration, login, and connection ceremony all depend on. Isolating them as pure logic modules with clear APIs enables the interactive flows in Plans 03-05 to compose them cleanly.

Output: auth module (password hashing, session CRUD, handle/email validation with profanity filter) and connection module (NodeManager with node tracking and assignment).
</objective>

<execution_context>
@C:\Users\chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-authentication-connection/02-RESEARCH.md

@backend/src/main.rs
@backend/src/config.rs
@backend/src/db/mod.rs
@backend/src/db/schema.sql
@backend/src/db/user.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth module (password, session, validation)</name>
  <files>
    backend/src/auth/mod.rs
    backend/src/auth/password.rs
    backend/src/auth/session.rs
    backend/src/auth/validation.rs
  </files>
  <action>
1. Create `backend/src/auth/mod.rs`:
   ```rust
   pub mod password;
   pub mod session;
   pub mod validation;
   ```

2. Create `backend/src/auth/password.rs`:
   - `pub fn hash_password(password: &str) -> Result<String, argon2::password_hash::Error>` -- Uses Argon2id with OWASP 2026 params: m=19456 KiB (19 MiB), t=2 iterations, p=1 parallelism. Generate salt with SaltString::generate(&mut OsRng). Return PHC-formatted hash string.
   - `pub fn verify_password(password: &str, hash: &str) -> Result<bool, argon2::password_hash::Error>` -- Parse stored hash with PasswordHash::new(), verify with argon2.verify_password(). Return Ok(true) if match, Ok(false) if mismatch (not Err).
   - Note: These are CPU-intensive blocking functions. Callers should use tokio::task::spawn_blocking() when calling from async context.

3. Create `backend/src/auth/session.rs`:
   - Use sqlx::SqlitePool for all DB operations
   - `pub fn generate_token() -> String` -- uuid::Uuid::new_v4().to_string()
   - `pub async fn create_session(pool: &SqlitePool, user_id: i64, node_id: Option<i32>, duration_hours: u32) -> Result<String, sqlx::Error>` -- Generate token, compute expires_at as now + duration_hours, INSERT into sessions table, return token
   - `pub async fn validate_session(pool: &SqlitePool, token: &str) -> Result<Option<i64>, sqlx::Error>` -- SELECT user_id from sessions WHERE token = ? AND datetime(expires_at) > datetime('now'). Return Some(user_id) if valid, None if expired/not found. Also update last_activity to now.
   - `pub async fn delete_session(pool: &SqlitePool, token: &str) -> Result<(), sqlx::Error>` -- DELETE from sessions WHERE token = ?
   - `pub async fn delete_user_sessions(pool: &SqlitePool, user_id: i64) -> Result<(), sqlx::Error>` -- DELETE from sessions WHERE user_id = ?
   - `pub async fn cleanup_expired_sessions(pool: &SqlitePool) -> Result<u64, sqlx::Error>` -- DELETE from sessions WHERE datetime(expires_at) < datetime('now'). Return rows affected.
   - `pub async fn get_active_session_for_user(pool: &SqlitePool, user_id: i64) -> Result<Option<String>, sqlx::Error>` -- Check if user already has a valid session (for duplicate session policy)

4. Create `backend/src/auth/validation.rs`:
   - `pub fn validate_handle(handle: &str) -> Result<(), String>` -- Checks:
     a. Length 3-20 chars (after trimming)
     b. Only alphanumeric + spaces (handle.chars().all(|c| c.is_alphanumeric() || c == ' '))
     c. Cannot start or end with space
     d. No consecutive spaces
     e. Not a reserved name (case-insensitive): "sysop", "admin", "guest", "system", "operator"
     f. Profanity check using rustrict: `use rustrict::CensorStr; !handle.is_inappropriate()` -- Returns Err(String) with user-friendly message on failure
   - `pub fn validate_email(email: &str) -> Result<(), String>` -- Basic validation:
     a. Contains exactly one '@'
     b. Has characters before and after '@'
     c. Domain part contains at least one '.'
     d. Total length <= 254 chars
     (Don't over-validate -- email verification confirms deliverability)
   - `pub fn validate_password(password: &str) -> Result<(), String>` -- Checks:
     a. Minimum 6 characters
     b. Maximum 128 characters (Argon2 can handle more, but set reasonable limit)
  </action>
  <verify>
Run `cd C:/Git/bbs/backend && cargo test` -- write unit tests inline:
- password: hash then verify succeeds, verify with wrong password fails
- validation: valid handle passes, too-short/too-long/profane handles fail, valid/invalid email
- session: generate_token returns valid UUID format
  </verify>
  <done>Auth module compiles with password hashing (Argon2id OWASP params), session CRUD, and validation (handle rules, profanity filter, email, password). Unit tests pass for all three submodules.</done>
</task>

<task type="auto">
  <name>Task 2: Create NodeManager and wire into AppState</name>
  <files>
    backend/src/connection/mod.rs
    backend/src/connection/node_manager.rs
    backend/src/main.rs
  </files>
  <action>
1. Create `backend/src/connection/mod.rs`:
   ```rust
   pub mod node_manager;
   pub use node_manager::NodeManager;
   ```

2. Create `backend/src/connection/node_manager.rs`:
   - `NodeManager` struct with `active_nodes: Arc<RwLock<HashMap<usize, NodeInfo>>>` and `max_nodes: usize`
   - `NodeInfo` struct: user_id (i64), handle (String), connected_at (chrono::DateTime<chrono::Utc>)
   - `impl NodeManager`:
     - `pub fn new(max_nodes: usize) -> Self`
     - `pub async fn assign_node(&self, user_id: i64, handle: String) -> Result<usize, String>` -- Write-lock, check if len >= max_nodes (return Err "All lines busy" if full). Find first available node number from 1..=max_nodes. Insert NodeInfo. Return Ok(node_id).
     - `pub async fn release_node(&self, node_id: usize)` -- Write-lock, remove node_id entry.
     - `pub async fn get_status(&self) -> (usize, usize)` -- Read-lock, return (active_count, max_nodes).
     - `pub async fn get_active_nodes(&self) -> Vec<(usize, String)>` -- Read-lock, return vec of (node_id, handle) sorted by node_id.
     - `pub async fn is_user_connected(&self, user_id: i64) -> bool` -- Read-lock, check if any NodeInfo has matching user_id.
     - `pub async fn get_node_for_user(&self, user_id: i64) -> Option<usize>` -- Read-lock, find node_id for given user_id.
   - Derive Clone on NodeManager (Arc inside makes this cheap).

3. Update `backend/src/main.rs`:
   - Add `mod auth;` and `mod connection;` declarations
   - Add `use connection::NodeManager;`
   - Add `node_manager: NodeManager` to AppState struct
   - In main(), create NodeManager with `NodeManager::new(config.connection.max_nodes as usize)` and add to AppState
   - Print node capacity: `println!("Node capacity: {} nodes", config.connection.max_nodes);`
  </action>
  <verify>
Run `cd C:/Git/bbs/backend && cargo check && cargo test` -- NodeManager compiles and integrates with AppState. Write unit tests:
- assign_node returns sequential node IDs
- assign_node returns error when full
- release_node frees a slot
- get_status returns correct counts
  </verify>
  <done>NodeManager tracks active connections with RwLock<HashMap>, enforces max_nodes limit, assigns first-available node numbers. Integrated into AppState. Unit tests pass for assignment, release, and capacity enforcement.</done>
</task>

</tasks>

<verification>
1. `cargo check` passes
2. `cargo test` passes with new unit tests for password, validation, session, and node_manager
3. Server starts with "Node capacity: 16 nodes" printed
4. Auth module provides clean API surface for Plans 03-05
</verification>

<success_criteria>
- Argon2id hashing uses OWASP 2026 parameters (19 MiB, 2 iterations, 1 parallelism)
- Session tokens are UUID v4, stored in SQLite with expiry
- Handle validation rejects profanity (including leetspeak via rustrict), enforces character rules
- NodeManager correctly assigns/releases nodes with concurrency safety (RwLock)
- All modules integrated into main.rs AppState
- Unit tests cover happy path and error cases
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-connection/02-02-SUMMARY.md`
</output>
